--PLSQL
--CMD에서 실행, cmd에서만 /로 실행
--기본적으로 출력기능 OFF되있음, 창 닫으면 다시 OFF로 바뀜
SET SERVEROUTPUT ON;


--이름없는 PROCEDURE, FILE로 보통 저장해놓고 사용

--데이터타입 가져오기
DECLARE
TYPE FIRSTTYPE IS RECORD
(A 사원.사원명%TYPE, B 사원.직급%TYPE,C 사원.급여%TYPE);

--FIRSTTYPE 타입의 변수 CUS 생성, 원본데이터 직접 안씀
CUS FIRSTTYPE;

BEGIN
SELECT 사원명,직급,급여 INTO CUS FROM 사원
WHERE 사원번호=2001;

DBMS_OUTPUT.PUT_LINE('사원명  직급  급여');
DBMS_OUTPUT.PUT_LINE('------------------');
DBMS_OUTPUT.PUT_LINE(CUS.A||'   '||CUS.B||'   '||TO_CHAR(CUS.C));
DBMS_OUTPUT.PUT_LINE('현재 질의한 계정명 : '||USER);
DBMS_OUTPUT.PUT_LINE('질의한 시간 : '||TO_CHAR(SYSDATE,'YYYY-MM-DD HH:MI:SS'));
END;


--사원테이블의 행의 모든 데이터타입 가져옴
DECLARE 
SAWON_REC 사원%ROWTYPE;

BEGIN
SELECT * INTO SAWON_REC FROM 사원 WHERE 사원번호=2001;
DBMS_OUTPUT.PUT_LINE('사원번호 : '||SAWON_REC.사원번호);
DBMS_OUTPUT.PUT_LINE('사원명 : '||SAWON_REC.사원명);
DBMS_OUTPUT.PUT_LINE('직급 : '||SAWON_REC.직급);
DBMS_OUTPUT.PUT_LINE('급여 : '||SAWON_REC.급여);
END;


--사원명,직급 컬럼타입 가져오고 인덱스 부여
DECLARE
TYPE SA_COL_TYPE IS TABLE OF 사원.사원명%TYPE
INDEX BY BINARY_INTEGER;

TYPE JIK_COL_TYPE IS TABLE OF 사원.직급%TYPE
INDEX BY BINARY_INTEGER;

--앞에가 변수명 뒤에가 데이터타입, 변수 선언
SANAME_COL SA_COL_TYPE;
SAJIK_COL JIK_COL_TYPE;

-- := 대입연산자, I에 0대입
I BINARY_INTEGER := 0;

BEGIN
FOR K IN (SELECT 사원명,직급 FROM 사원) LOOP
I := I+1; -- ORCLE은 인덱스1부터 시작
SANAME_COL(I) := K.사원명;
SAJIK_COL(I) := K.직급;

END LOOP;--FOR문 닫기

DBMS_OUTPUT.PUT_LINE('사원명  직급');
DBMS_OUTPUT.PUT_LINE('------------');

--1부터 I까지 반복
FOR J IN 1..I LOOP
DBMS_OUTPUT.PUT_LINE(RPAD(SANAME_COL(J),12)||RPAD(SAJIK_COL(J),9));
END LOOP;
END;



--이름 있는 PROCEDURE 생성
--IN 은 매개변수, 생략해도됨
CREATE OR REPLACE PROCEDURE CHANG_PAY
(V_SANO IN NUMBER,V_NEW_PAY IN NUMBER)
IS --IS 위에 쓰는 변수는 가져오는 매개변수,IS 아래쓰는 변수는 로컬변수
BEGIN UPDATE 사원 SET 급여=V_NEW_PAY WHERE 사원번호=V_SANO;
COMMIT;
END CHANG_PAY; --이름 생략가능


--PROCEDURE 사용
EXECUTE CHANG_PAY(2001,5000);

EXEC CHANG_PAY(2002,4500);


--함수, 반환값 있음
CREATE OR REPLACE FUNCTION F_TAX
(V_SANO IN NUMBER)
RETURN NUMBER
IS
V_TAX NUMBER;

BEGIN
SELECT ((급여 * 12) + NVL(커미션,0))*0.05 INTO V_TAX --SELECT라 커밋 필요 없음
FROM 사원 WHERE 사원번호=V_SANO;
RETURN V_TAX;
END F_TAX;


--OUT : 프로시저, 함수 둘다 사용가능, 반환값 여러개 가능
--RETURN : 함수만 사용 가능, 반환값 한개만 가능,
CREATE OR REPLACE PROCEDURE P_OUTEX
(V_SANO IN 사원.사원번호%TYPE, V_SANAME OUT 사원.사원명%TYPE, V_PAY OUT 사원.급여%TYPE, V_COMM OUT 사원.커미션%TYPE)
IS
BEGIN
SELECT 사원명,급여,커미션 INTO V_SANAME,V_PAY,V_COMM
FROM 사원 WHERE 사원번호=V_SANO;
END P_OUTEX;


--쿼리박스에선 변수 생성 안된다, cmd ㄱㄱ
--변수 생성
--:변수 = sql과 plsql 간 변수 전달 할때 : 붙임, plsql내부 변수에는 안붙임
VARIABLE NAME VARCHAR2(10);
VARIABLE PAY NUMBER;
VARIABLE COMM NUMBER;
EXEC P_OUTEX(2001,:NAME,:PAY,:COMM);


SELECT :NAME,:PAY,:COMM FROM DUAL;


CREATE OR REPLACE PROCEDURE ADD_ONE
(V_TEL IN OUT VARCHAR2)
IS
BEGIN
V_TEL := SUBSTR(V_TEL,1,3)||'-'||SUBSTR(V_TEL,4);
END;

VARIABLE TEL VARCHAR2(15);

EXEC :TEL := '1234567';

EXEC ADD_ONE(:TEL);

SELECT :TEL FROM DUAL;



CREATE OR REPLACE PROCEDURE P_GOJUTOT
(V_GNO IN VARCHAR2)
IS 
TOT NUMBER;

BEGIN
SELECT COUNT(*) INTO TOT FROM SALES
WHERE USERID=V_GNO;

DBMS_OUTPUT.PUT_LINE(V_GNO||'번 고객님의 총 주문 횟수는 '||TO_CHAR(TOT)||'번 입니다');
END;


EXECUTE P_GOJUTOT('og6675');

EXECUTE P_GOJUTOT('zz5785');

EXECUTE P_GOJUTOT('1m4623');



CREATE OR REPLACE PROCEDURE SEARCHJIK
(JIK IN VARCHAR2)
IS
A NUMBER :=0;
B NUMBER(12,2) :=0;
C NUMBER := 0;

BEGIN
SELECT SUM(PAY),AVG(PAY),COUNT(*) INTO A,B,C
FROM COMPANY WHERE POSIT=JIK;

DBMS_OUTPUT.PUT_LINE('급여 총액 : '||A||'원');
DBMS_OUTPUT.PUT_LINE('평균 월급 : '||B||'원');
DBMS_OUTPUT.PUT_LINE('인원수 : '||C||'명');
END;


EXEC SEARCHJIK('과장');



CREATE TABLE TEST
(A NUMBER(10),
B NUMBER(10),
C DATE DEFAULT SYSDATE);

--INSERT PROCEDURE
CREATE OR REPLACE PROCEDURE P_EX
(FIRST NUMBER, SECOND IN NUMBER)
IS
BEGIN
INSERT INTO TEST (A,B) VALUES (FIRST,SECOND);
COMMIT;
END;

EXEC P_EX(10,20);

SELECT * FROM TEST;



SELECT * FROM CUSTOM;
DESC CUSTOM;
--CUSTOM테이블에 INSERT시키는 PROCEDURE
--CREATE OR REPLACE PROCEDURE CUS_IN

--PLSQL에서만 VARCHAR2같은데에 길이 지정안해줘도됨
CREATE OR REPLACE PROCEDURE CUS_IN
(A VARCHAR2, B VARCHAR2,C VARCHAR2,D NUMBER,E VARCHAR2,F VARCHAR2,
G VARCHAR2, H VARCHAR2, I VARCHAR2,J VARCHAR2,K VARCHAR2,L VARCHAR2,
N NUMBER,M DATE)
IS
BEGIN
INSERT INTO CUSTOM VALUES(A,B,C,D,E,F,G,H,I,J,K,L,N,M);
COMMIT;
END;


EXEC CUS_IN('ASD123','김김김','123456-12347',21,'0','4156-486','경기도','안산시','고잔동','123-4567','백수','학교',123,SYSDATE);

SELECT * FROM CUSTOM WHERE USERID = 'ASD123';

--CUSTOM테이블에 UPDATE시키는 PROCEDURE
--CREATE OR REPLACE PROCEDURE CUS_UP

CREATE OR REPLACE PROCEDURE CUS_UP
(A VARCHAR2, B VARCHAR2,C VARCHAR2,D NUMBER,E VARCHAR2,F VARCHAR2,
G VARCHAR2, H VARCHAR2, I VARCHAR2,J VARCHAR2,K VARCHAR2,L VARCHAR2,
N NUMBER,M DATE)
IS
BEGIN
UPDATE CUSTOM SET USERNAME = B,JUMIN=C,AGE=D,SEX=E,ZIP=F,ADDR1=G,ADDR2=H,ADDR3=I,TEL=J,JOB=K,SCHOL=L,
POINT=N,REGDATE=M WHERE USERID = A;
COMMIT;
END;


--쿼리박스에서는 EXEC,EXECUTE 오류 잘남 둘다 해보셈, 안되면 CMD ㄱ
EXECUTE CUS_UP('ASD123','박박박','123456-12347',22,'0','4156-486','경기도','안산시','고잔동','123-4567','백','학교',123,SYSDATE);

SELECT * FROM CUSTOM WHERE USERID = 'ASD123';


--CUSTOM테이블에 DELETE시키는 PROCEDURE
--CREATE OR REPLACE PROCEDURE CUS_DEL

CREATE OR REPLACE PROCEDURE CUS_DEL
(A VARCHAR2)
IS
BEGIN
DELETE CUSTOM WHERE USERID = A;
COMMIT;
END;

EXEC CUS_DEL('ASD123');

SELECT * FROM CUSTOM WHERE USERID = 'ASD123';


--부피 구하는 함수
--RETURN이 IS위에 있으면 ;안씀
CREATE OR REPLACE FUNCTION F_CUBVOL
(GILI IN NUMBER, POK IN NUMBER,NOPI IN NUMBER)
RETURN NUMBER
IS
BUPI NUMBER;
BEGIN
BUPI :=GILI*POK*NOPI;
RETURN BUPI;
END;


SELECT F_CUBVOL(4,7,9) BUPI FROM DUAL;


--입력받은 날짜의 말일 구하기
CREATE OR REPLACE FUNCTION F_MONLAST
(V_DATE DATE)
RETURN DATE
IS
LASTDATE DATE;
BEGIN
LASTDATE := (ADD_MONTHS(V_DATE,1)-TO_CHAR(V_DATE,'DD'));
RETURN LASTDATE;
END;


SELECT F_MONLAST('2025-07-29') FROM DUAL;

SELECT USERID,USERNAME,REGDATE,F_MONLAST(REGDATE) FROM CUSTOM WHERE USERID='ASD123';


--성명을 입력받아 성을 뺀 이름만 반환

CREATE OR REPLACE FUNCTION F_NAME
(A IN VARCHAR2)
RETURN VARCHAR2
IS
B VARCHAR2(8);
BEGIN
B:=SUBSTR(A,-2);
RETURN B;
END;


SELECT USERNAME,F_NAME(USERNAME) 이름 FROM CUSTOM WHERE USERID='gg5595';
--SQLPLUS,간격 8칸으로 줄여줌, 창 닫히면 초기화
COL 이름 FORMAT A8;
COL USERNAME FORMAT A8;


SELECT
FLOOR(MONTHS_BETWEEN(SYSDATE,'2002-04-01')/12)||'년'||
FLOOR(MOD(MONTHS_BETWEEN(SYSDATE,'2002-04-01'),12))||'개월'
FROM DUAL;


CREATE OR REPLACE FUNCTION F_STARTDAY
(V_DATE IN DATE)
RETURN VARCHAR2
IS
GUNDATE VARCHAR2(20);
BEGIN
GUNDATE:=FLOOR(MONTHS_BETWEEN(SYSDATE,V_DATE)/12)||'년'||
FLOOR(MOD(MONTHS_BETWEEN(SYSDATE,V_DATE),12))||'개월';
RETURN GUNDATE;
END;


SELECT USERNAME,REGDATE,F_STARTDAY(REGDATE) GUNDATE 
FROM CUSTOM 
WHERE ADDR1 LIKE '제주%';


--주민번호 입력했을때 성별을 반환
--IF문
CREATE OR REPLACE FUNCTION F_GENDER
(V_JUMIN IN VARCHAR2)
RETURN VARCHAR2
IS
GENDER VARCHAR2(6);
BEGIN
GENDER:=SUBSTR(V_JUMIN,8,1);
IF GENDER IN ('1','3') THEN
GENDER := '남자';
ELSE
GENDER:= '여자';
END IF;
RETURN GENDER;
END;

SELECT USERNAME,JUMIN,F_GENDER(JUMIN) GENDER
FROM CUSTOM WHERE ADDR1='제주도';


--날짜의 년수,개월수,날수를 더하는 함수
CREATE OR REPLACE FUNCTION GAEYAK
(V_DATE IN DATE,Y IN NUMBER,M IN NUMBER,D IN NUMBER)
RETURN DATE
IS
NALZA DATE;
BEGIN
NALZA := ADD_MONTHS(V_DATE,Y*12);
NALZA := ADD_MONTHS(NALZA,M);
NALZA := NALZA+D;
RETURN NALZA;
END;

SELECT USERNAME,TO_CHAR(REGDATE,'YYYY-MM-DD') REGDATE,TO_CHAR(GAEYAK(REGDATE,1,11,29),'YYYY-MM-DD') GAEYAK
FROM CUSTOM WHERE ADDR1='제주도';


--ELSEIF문, ELSIF 임 E 없음
CREATE OR REPLACE FUNCTION F_PAYGRADE
(V_PAY IN NUMBER)
RETURN VARCHAR2
IS
RESULT VARCHAR2(20);
BEGIN
IF V_PAY > 2500000 THEN
RESULT:='A';
ELSIF V_PAY> 2000000 THEN
RESULT:='B';
ELSIF V_PAY> 1500000 THEN
RESULT:='C';
ELSIF V_PAY> 1000000 THEN
RESULT:='D';
ELSE
RESULT := 'E';
END IF;
RETURN RESULT;
END;

--SQLPLUS에서만 하셈
COL PAYGRADE FORMAT A8;
COL POSIT FORMAT A8;

SELECT USERID,POSIT,PAY,F_PAYGRADE(PAY)||'등급' PAYGRADE
FROM COMPANY WHERE USERID='XA9776';

SELECT USERID,POSIT,PAY,F_PAYGRADE(PAY)||'등급' PAYGRADE
FROM COMPANY WHERE USERID='ye8802';


--반복문

CREATE OR REPLACE PROCEDURE BANBOK1
(V_START NUMBER,V_END NUMBER)
IS
TOT NUMBER:=0;

BEGIN
FOR I IN V_START..V_END LOOP
TOT := TOT + I ;
END LOOP;

DBMS_OUTPUT.PUT_LINE(TO_CHAR(V_START)||'부터'||TO_CHAR(V_END)||'까지의 합은 '||TO_CHAR(TOT)||'입니다');
END;

EXEC BANBOK1(1,100);


--반복문2, LOOP문,(DO~WHILE)
CREATE OR REPLACE PROCEDURE BANBOK2
(V_START NUMBER,V_END NUMBER)
IS
CNT NUMBER:= V_START;
TOT NUMBER:=0;

BEGIN
LOOP
TOT := TOT+CNT;
CNT := CNT+1;
EXIT WHEN CNT > V_END;
END LOOP;

DBMS_OUTPUT.PUT_LINE(TO_CHAR(V_START)||'부터'||TO_CHAR(V_END)||'까지의 합은 '||TO_CHAR(TOT)||'입니다');
END;

EXEC BANBOK2(1,100);


--WHILE문
CREATE OR REPLACE PROCEDURE BANBOK3
(V_START NUMBER,V_END NUMBER)
IS
CNT NUMBER:= V_START;
TOT NUMBER:=0;

BEGIN
WHILE CNT <= V_END LOOP
TOT := TOT+CNT;
CNT := CNT+1;
END LOOP;

DBMS_OUTPUT.PUT_LINE(TO_CHAR(V_START)||'부터'||TO_CHAR(V_END)||'까지의 합은 '||TO_CHAR(TOT)||'입니다');
END;

EXEC BANBOK3(1,100);












