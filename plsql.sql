--PLSQL
--CMD에서 실행, cmd에서만 /로 실행
--기본적으로 출력기능 OFF되있음, 창 닫으면 다시 OFF로 바뀜
SET SERVEROUTPUT ON;


--이름없는 PROCEDURE, FILE로 보통 저장해놓고 사용

--데이터타입 가져오기
DECLARE
TYPE FIRSTTYPE IS RECORD
(A 사원.사원명%TYPE, B 사원.직급%TYPE,C 사원.급여%TYPE);

--FIRSTTYPE 타입의 변수 CUS 생성, 원본데이터 직접 안씀
CUS FIRSTTYPE;

BEGIN
SELECT 사원명,직급,급여 INTO CUS FROM 사원
WHERE 사원번호=2001;

DBMS_OUTPUT.PUT_LINE('사원명  직급  급여');
DBMS_OUTPUT.PUT_LINE('------------------');
DBMS_OUTPUT.PUT_LINE(CUS.A||'   '||CUS.B||'   '||TO_CHAR(CUS.C));
DBMS_OUTPUT.PUT_LINE('현재 질의한 계정명 : '||USER);
DBMS_OUTPUT.PUT_LINE('질의한 시간 : '||TO_CHAR(SYSDATE,'YYYY-MM-DD HH:MI:SS'));
END;


--사원테이블의 행의 모든 데이터타입 가져옴
DECLARE 
SAWON_REC 사원%ROWTYPE;

BEGIN
SELECT * INTO SAWON_REC FROM 사원 WHERE 사원번호=2001;
DBMS_OUTPUT.PUT_LINE('사원번호 : '||SAWON_REC.사원번호);
DBMS_OUTPUT.PUT_LINE('사원명 : '||SAWON_REC.사원명);
DBMS_OUTPUT.PUT_LINE('직급 : '||SAWON_REC.직급);
DBMS_OUTPUT.PUT_LINE('급여 : '||SAWON_REC.급여);
END;


--사원명,직급 컬럼타입 가져오고 인덱스 부여
DECLARE
TYPE SA_COL_TYPE IS TABLE OF 사원.사원명%TYPE
INDEX BY BINARY_INTEGER;

TYPE JIK_COL_TYPE IS TABLE OF 사원.직급%TYPE
INDEX BY BINARY_INTEGER;

--앞에가 변수명 뒤에가 데이터타입, 변수 선언
SANAME_COL SA_COL_TYPE;
SAJIK_COL JIK_COL_TYPE;

-- := 대입연산자, I에 0대입
I BINARY_INTEGER := 0;

BEGIN
FOR K IN (SELECT 사원명,직급 FROM 사원) LOOP
I := I+1; -- ORCLE은 인덱스1부터 시작
SANAME_COL(I) := K.사원명;
SAJIK_COL(I) := K.직급;

END LOOP;--FOR문 닫기

DBMS_OUTPUT.PUT_LINE('사원명  직급');
DBMS_OUTPUT.PUT_LINE('------------');

--1부터 I까지 반복
FOR J IN 1..I LOOP
DBMS_OUTPUT.PUT_LINE(RPAD(SANAME_COL(J),12)||RPAD(SAJIK_COL(J),9));
END LOOP;
END;



--이름 있는 PROCEDURE 생성
--IN 은 매개변수, 생략해도됨
CREATE OR REPLACE PROCEDURE CHANG_PAY
(V_SANO IN NUMBER,V_NEW_PAY IN NUMBER)
IS --IS 위에 쓰는 변수는 가져오는 매개변수,IS 아래쓰는 변수는 로컬변수
BEGIN 
UPDATE 사원 SET 급여=V_NEW_PAY WHERE 사원번호=V_SANO;
COMMIT;
END CHANG_PAY; --이름 생략가능


--PROCEDURE 사용
EXECUTE CHANG_PAY(2001,5000);

EXEC CHANG_PAY(2002,4500);


--함수, 반환값 있음
CREATE OR REPLACE FUNCTION F_TAX
(V_SANO IN NUMBER)
RETURN NUMBER
IS
V_TAX NUMBER;

BEGIN
SELECT ((급여 * 12) + NVL(커미션,0))*0.05 INTO V_TAX --SELECT라 커밋 필요 없음
FROM 사원 WHERE 사원번호=V_SANO;
RETURN V_TAX;
END F_TAX;


--OUT : 프로시저, 함수 둘다 사용가능, 반환값 여러개 가능
--RETURN : 함수만 사용 가능, 반환값 한개만 가능,
CREATE OR REPLACE PROCEDURE P_OUTEX
(V_SANO IN 사원.사원번호%TYPE, V_SANAME OUT 사원.사원명%TYPE, V_PAY OUT 사원.급여%TYPE, V_COMM OUT 사원.커미션%TYPE)
IS
BEGIN
SELECT 사원명,급여,커미션 INTO V_SANAME,V_PAY,V_COMM
FROM 사원 WHERE 사원번호=V_SANO;
END P_OUTEX;


--쿼리박스에선 변수 생성 안된다, cmd ㄱㄱ
--변수 생성
--:변수 = sql과 plsql 간 변수 전달 할때 : 붙임, plsql내부 변수에는 안붙임
VARIABLE NAME VARCHAR2(10);
VARIABLE PAY NUMBER;
VARIABLE COMM NUMBER;
EXEC P_OUTEX(2001,:NAME,:PAY,:COMM);


SELECT :NAME,:PAY,:COMM FROM DUAL;


CREATE OR REPLACE PROCEDURE ADD_ONE
(V_TEL IN OUT VARCHAR2)
IS
BEGIN
V_TEL := SUBSTR(V_TEL,1,3)||'-'||SUBSTR(V_TEL,4);
END;

VARIABLE TEL VARCHAR2(15);

EXEC :TEL := '1234567';

EXEC ADD_ONE(:TEL);

SELECT :TEL FROM DUAL;



CREATE OR REPLACE PROCEDURE P_GOJUTOT
(V_GNO IN VARCHAR2)
IS 
TOT NUMBER;

BEGIN
SELECT COUNT(*) INTO TOT FROM SALES
WHERE USERID=V_GNO;

DBMS_OUTPUT.PUT_LINE(V_GNO||'번 고객님의 총 주문 횟수는 '||TO_CHAR(TOT)||'번 입니다');
END;


EXECUTE P_GOJUTOT('og6675');

EXECUTE P_GOJUTOT('zz5785');

EXECUTE P_GOJUTOT('1m4623');



CREATE OR REPLACE PROCEDURE SEARCHJIK
(JIK IN VARCHAR2)
IS
A NUMBER :=0;
B NUMBER(12,2) :=0;
C NUMBER := 0;

BEGIN
SELECT SUM(PAY),AVG(PAY),COUNT(*) INTO A,B,C
FROM COMPANY WHERE POSIT=JIK;

DBMS_OUTPUT.PUT_LINE('급여 총액 : '||A||'원');
DBMS_OUTPUT.PUT_LINE('평균 월급 : '||B||'원');
DBMS_OUTPUT.PUT_LINE('인원수 : '||C||'명');
END;


EXEC SEARCHJIK('과장');



CREATE TABLE TEST
(A NUMBER(10),
B NUMBER(10),
C DATE DEFAULT SYSDATE);

--INSERT PROCEDURE
CREATE OR REPLACE PROCEDURE P_EX
(FIRST NUMBER, SECOND IN NUMBER)
IS
BEGIN
INSERT INTO TEST (A,B) VALUES (FIRST,SECOND);
COMMIT;
END;

EXEC P_EX(10,20);

SELECT * FROM TEST;



SELECT * FROM CUSTOM;
DESC CUSTOM;
--CUSTOM테이블에 INSERT시키는 PROCEDURE
--CREATE OR REPLACE PROCEDURE CUS_IN

--PLSQL에서만 VARCHAR2같은데에 길이 지정안해줘도됨
CREATE OR REPLACE PROCEDURE CUS_IN
(A VARCHAR2, B VARCHAR2,C VARCHAR2,D NUMBER,E VARCHAR2,F VARCHAR2,
G VARCHAR2, H VARCHAR2, I VARCHAR2,J VARCHAR2,K VARCHAR2,L VARCHAR2,
N NUMBER,M DATE)
IS
BEGIN
INSERT INTO CUSTOM VALUES(A,B,C,D,E,F,G,H,I,J,K,L,N,M);
COMMIT;
END;


EXEC CUS_IN('ASD123','김김김','123456-12347',21,'0','4156-486','경기도','안산시','고잔동','123-4567','백수','학교',123,SYSDATE);

SELECT * FROM CUSTOM WHERE USERID = 'ASD123';

--CUSTOM테이블에 UPDATE시키는 PROCEDURE
--CREATE OR REPLACE PROCEDURE CUS_UP

CREATE OR REPLACE PROCEDURE CUS_UP
(A VARCHAR2, B VARCHAR2,C VARCHAR2,D NUMBER,E VARCHAR2,F VARCHAR2,
G VARCHAR2, H VARCHAR2, I VARCHAR2,J VARCHAR2,K VARCHAR2,L VARCHAR2,
N NUMBER,M DATE)
IS
BEGIN
UPDATE CUSTOM SET USERNAME = B,JUMIN=C,AGE=D,SEX=E,ZIP=F,ADDR1=G,ADDR2=H,ADDR3=I,TEL=J,JOB=K,SCHOL=L,
POINT=N,REGDATE=M WHERE USERID = A;
COMMIT;
END;


--쿼리박스에서는 EXEC,EXECUTE 오류 잘남 둘다 해보셈, 안되면 CMD ㄱ
EXECUTE CUS_UP('ASD123','박박박','123456-12347',22,'0','4156-486','경기도','안산시','고잔동','123-4567','백','학교',123,SYSDATE);

SELECT * FROM CUSTOM WHERE USERID = 'ASD123';


--CUSTOM테이블에 DELETE시키는 PROCEDURE
--CREATE OR REPLACE PROCEDURE CUS_DEL

CREATE OR REPLACE PROCEDURE CUS_DEL
(A VARCHAR2)
IS
BEGIN
DELETE CUSTOM WHERE USERID = A;
COMMIT;
END;

EXEC CUS_DEL('ASD123');

SELECT * FROM CUSTOM WHERE USERID = 'ASD123';


--부피 구하는 함수
--RETURN이 IS위에 있으면 ;안씀
CREATE OR REPLACE FUNCTION F_CUBVOL
(GILI IN NUMBER, POK IN NUMBER,NOPI IN NUMBER)
RETURN NUMBER
IS
BUPI NUMBER;
BEGIN
BUPI :=GILI*POK*NOPI;
RETURN BUPI;
END;


SELECT F_CUBVOL(4,7,9) BUPI FROM DUAL;


--입력받은 날짜의 말일 구하기
CREATE OR REPLACE FUNCTION F_MONLAST
(V_DATE DATE)
RETURN DATE
IS
LASTDATE DATE;
BEGIN
LASTDATE := (ADD_MONTHS(V_DATE,1)-TO_CHAR(V_DATE,'DD'));
RETURN LASTDATE;
END;


SELECT F_MONLAST('2025-07-29') FROM DUAL;

SELECT USERID,USERNAME,REGDATE,F_MONLAST(REGDATE) FROM CUSTOM WHERE USERID='ASD123';


--성명을 입력받아 성을 뺀 이름만 반환

CREATE OR REPLACE FUNCTION F_NAME
(A IN VARCHAR2)
RETURN VARCHAR2
IS
B VARCHAR2(8);
BEGIN
B:=SUBSTR(A,-2);
RETURN B;
END;


SELECT USERNAME,F_NAME(USERNAME) 이름 FROM CUSTOM WHERE USERID='gg5595';
--SQLPLUS,간격 8칸으로 줄여줌, 창 닫히면 초기화
COL 이름 FORMAT A8;
COL USERNAME FORMAT A8;


SELECT
FLOOR(MONTHS_BETWEEN(SYSDATE,'2002-04-01')/12)||'년'||
FLOOR(MOD(MONTHS_BETWEEN(SYSDATE,'2002-04-01'),12))||'개월'
FROM DUAL;


CREATE OR REPLACE FUNCTION F_STARTDAY
(V_DATE IN DATE)
RETURN VARCHAR2
IS
GUNDATE VARCHAR2(20);
BEGIN
GUNDATE:=FLOOR(MONTHS_BETWEEN(SYSDATE,V_DATE)/12)||'년'||
FLOOR(MOD(MONTHS_BETWEEN(SYSDATE,V_DATE),12))||'개월';
RETURN GUNDATE;
END;


SELECT USERNAME,REGDATE,F_STARTDAY(REGDATE) GUNDATE 
FROM CUSTOM 
WHERE ADDR1 LIKE '제주%';


--주민번호 입력했을때 성별을 반환
--IF문
CREATE OR REPLACE FUNCTION F_GENDER
(V_JUMIN IN VARCHAR2)
RETURN VARCHAR2
IS
GENDER VARCHAR2(6);
BEGIN
GENDER:=SUBSTR(V_JUMIN,8,1);
IF GENDER IN ('1','3') THEN
GENDER := '남자';
ELSE
GENDER:= '여자';
END IF;
RETURN GENDER;
END;

SELECT USERNAME,JUMIN,F_GENDER(JUMIN) GENDER
FROM CUSTOM WHERE ADDR1='제주도';


--날짜의 년수,개월수,날수를 더하는 함수
CREATE OR REPLACE FUNCTION GAEYAK
(V_DATE IN DATE,Y IN NUMBER,M IN NUMBER,D IN NUMBER)
RETURN DATE
IS
NALZA DATE;
BEGIN
NALZA := ADD_MONTHS(V_DATE,Y*12);
NALZA := ADD_MONTHS(NALZA,M);
NALZA := NALZA+D;
RETURN NALZA;
END;

SELECT USERNAME,TO_CHAR(REGDATE,'YYYY-MM-DD') REGDATE,TO_CHAR(GAEYAK(REGDATE,1,11,29),'YYYY-MM-DD') GAEYAK
FROM CUSTOM WHERE ADDR1='제주도';


--ELSEIF문, ELSIF 임 E 없음
CREATE OR REPLACE FUNCTION F_PAYGRADE
(V_PAY IN NUMBER)
RETURN VARCHAR2
IS
RESULT VARCHAR2(20);
BEGIN
IF V_PAY > 2500000 THEN
RESULT:='A';
ELSIF V_PAY> 2000000 THEN
RESULT:='B';
ELSIF V_PAY> 1500000 THEN
RESULT:='C';
ELSIF V_PAY> 1000000 THEN
RESULT:='D';
ELSE
RESULT := 'E';
END IF;
RETURN RESULT;
END;

--SQLPLUS에서만 하셈
COL PAYGRADE FORMAT A8;
COL POSIT FORMAT A8;

SELECT USERID,POSIT,PAY,F_PAYGRADE(PAY)||'등급' PAYGRADE
FROM COMPANY WHERE USERID='XA9776';

SELECT USERID,POSIT,PAY,F_PAYGRADE(PAY)||'등급' PAYGRADE
FROM COMPANY WHERE USERID='ye8802';


--반복문

CREATE OR REPLACE PROCEDURE BANBOK1
(V_START NUMBER,V_END NUMBER)
IS
TOT NUMBER:=0;

BEGIN
FOR I IN V_START..V_END LOOP
TOT := TOT + I ;
END LOOP;

DBMS_OUTPUT.PUT_LINE(TO_CHAR(V_START)||'부터'||TO_CHAR(V_END)||'까지의 합은 '||TO_CHAR(TOT)||'입니다');
END;

EXEC BANBOK1(1,100);


--반복문2, LOOP문,(DO~WHILE)
CREATE OR REPLACE PROCEDURE BANBOK2
(V_START NUMBER,V_END NUMBER)
IS
CNT NUMBER:= V_START;
TOT NUMBER:=0;

BEGIN
LOOP
TOT := TOT+CNT;
CNT := CNT+1;
EXIT WHEN CNT > V_END;
END LOOP;

DBMS_OUTPUT.PUT_LINE(TO_CHAR(V_START)||'부터'||TO_CHAR(V_END)||'까지의 합은 '||TO_CHAR(TOT)||'입니다');
END;

EXEC BANBOK2(1,100);


--WHILE문
CREATE OR REPLACE PROCEDURE BANBOK3
(V_START NUMBER,V_END NUMBER)
IS
CNT NUMBER:= V_START;
TOT NUMBER:=0;

BEGIN
WHILE CNT <= V_END LOOP
TOT := TOT+CNT;
CNT := CNT+1;
END LOOP;

DBMS_OUTPUT.PUT_LINE(TO_CHAR(V_START)||'부터'||TO_CHAR(V_END)||'까지의 합은 '||TO_CHAR(TOT)||'입니다');
END;

EXEC BANBOK3(1,100);

---------------------------------------

--예외처리

CREATE OR REPLACE PROCEDURE EXE_TEST
IS
SW_REC 사원%ROWTYPE;
BEGIN
SELECT * INTO SW_REC FROM 사원 WHERE 사원번호=2001;
DBMS_OUTPUT.PUT_LINE('데이터 검색 성공');

EXCEPTION
WHEN TOO_MANY_ROWS THEN
ROLLBACK;
DBMS_OUTPUT.PUT_LINE('데이터가 많습니다');

WHEN NO_DATA_FOUND THEN
ROLLBACK;
DBMS_OUTPUT.PUT_LINE('데이터가 없습니다');

WHEN OTHERS THEN
ROLLBACK;
DBMS_OUTPUT.PUT_LINE('기타 에러 입니다');
END;

EXEC EXE_TEST;


CREATE TABLE EMP2
(EMPNO NUMBER(4) PRIMARY KEY, ENAME VARCHAR2(10), DEPTNO NUMBER(2));

INSERT INTO EMP2 VALUES(1001,'배수지',1);

INSERT INTO EMP2 VALUES(1002,'이수지',2);

CREATE OR REPLACE PROCEDURE IN_EMP2
(EMPNO NUMBER,DEPTNO NUMBER)
IS
NAME VARCHAR2(10):='미지정';
BEGIN
INSERT INTO EMP2 VALUES(EMPNO,NAME,DEPTNO);
COMMIT;

EXCEPTION
WHEN DUP_VAL_ON_INDEX THEN
DBMS_OUTPUT.PUT_LINE('데이터 중복');
END;

EXEC IN_EMP2(1003,3);

EXEC IN_EMP2(1003,3);

SELECT * FROM EMP2;

--사용자 정의 예외처리

CREATE OR REPLACE PROCEDURE PAY_VALIDATE
(V_SANO 사원.사원번호%TYPE)
IS

NOT_ENOUGH_PAY EXCEPTION;

SW_REC 사원%ROWTYPE;

BEGIN
SELECT * INTO SW_REC FROM 사원 WHERE 사원번호 = V_SANO;

IF SW_REC.급여 >= 3000 THEN
DBMS_OUTPUT.PUT_LINE('급여가 3000이상으로 적당함');

ELSIF SW_REC.급여 < 3000 THEN
RAISE NOT_ENOUGH_PAY;

ELSE
DBMS_OUTPUT.PUT_LINE('급여가 이상함');
END IF;

EXCEPTION
WHEN NOT_ENOUGH_PAY THEN
RAISE_APPLICATION_ERROR(-20001,'급여가 충분하지 않음');--에러 번호지정
END;

EXEC PAY_VALIDATE(2001);

EXEC PAY_VALIDATE(2003);

---------------------------------------------------------------------------

--CURSOR
--여러 행과 열을 담는 그릇, 테이블 같음
--CURSOR사용하려면 OPEN으로 열고 FETCH로 데이터 꺼냄, CLOSE로 닫아줘야댐
 --NOTFOUND : 커서 내장변수, 데이터 없으면 TRUE
 --ROWCOUNT : 커서 내장변수, 레코드 갯수
 
CREATE OR REPLACE PROCEDURE P_DEPTNO
(DEPTNO 사원.부서번호%TYPE)
IS
	CURSOR CUR_DEPTDATA
	IS
	SELECT 부서번호,사원명,직급,급여 FROM 사원
	WHERE 부서번호=DEPTNO;

V_DEPTNO 사원.부서번호%TYPE;
V_SANAME 사원.사원명%TYPE;
V_JIK 사원.직급%TYPE;
V_SAL 사원.급여%TYPE;

BEGIN

OPEN CUR_DEPTDATA ;

DBMS_OUTPUT.PUT_LINE('부서번호  사원명  직급  급여');
DBMS_OUTPUT.PUT_LINE('----------------------------');

LOOP
FETCH CUR_DEPTDATA INTO V_DEPTNO,V_SANAME,V_JIK,V_SAL;

EXIT WHEN CUR_DEPTDATA%NOTFOUND;

DBMS_OUTPUT.PUT_LINE(TO_CHAR(V_DEPTNO)||'    '||V_SANAME||'    '||V_JIK||'    '||TO_CHAR(V_SAL));

END LOOP;
DBMS_OUTPUT.PUT_LINE('------------------------------');
DBMS_OUTPUT.PUT_LINE('전체 데이터의 갯수 : '||TO_CHAR(CUR_DEPTDATA%ROWCOUNT)); 

CLOSE CUR_DEPTDATA;
END;

EXEC P_DEPTNO(10);


SELECT * FROM 사원;

--FOR문 으로 변경
--자동으로 OPEN,FETCH,CLOSE됨
CREATE OR REPLACE PROCEDURE P_DEPTNO1
(DEPTNO 사원.부서번호%TYPE)
IS
	CURSOR CUR_DEPTDATA
	IS
	SELECT 부서번호,사원명,직급,급여 FROM 사원
	WHERE 부서번호=DEPTNO;

CNT NUMBER;

BEGIN

DBMS_OUTPUT.PUT_LINE('부서번호  사원명  직급  급여');
DBMS_OUTPUT.PUT_LINE('----------------------------');

FOR CURDEPT IN CUR_DEPTDATA LOOP

DBMS_OUTPUT.PUT_LINE(TO_CHAR(CURDEPT.부서번호)||'    '||CURDEPT.사원명||'    '||CURDEPT.직급||'    '||TO_CHAR(CURDEPT.급여));

CNT := CUR_DEPTDATA%ROWCOUNT;

END LOOP;

DBMS_OUTPUT.PUT_LINE('------------------------------');
DBMS_OUTPUT.PUT_LINE('전체 데이터의 갯수 : '||TO_CHAR(CNT)); 

END;
/

EXEC P_DEPTNO1(20);


--USERID 입력시 사원이름(CUSTOM)과 구입한 제품명(SALES) 출력

CREATE OR REPLACE PROCEDURE P_JEPUM
(V_USERID VARCHAR2)
IS 
V_CNT NUMBER;

CURSOR SA_CUR
IS
SELECT C.USERID,C.USERNAME,S.PRODUCTNAME
FROM CUSTOM C, SALES S WHERE C.USERID=S.USERID AND S.USERID=V_USERID;

BEGIN
DBMS_OUTPUT.PUT_LINE('아이디  이름  구입제품명');
DBMS_OUTPUT.PUT_LINE('-------------------------');

FOR SA_REC IN SA_CUR LOOP

DBMS_OUTPUT.PUT_LINE(SA_REC.USERID||'    '||SA_REC.USERNAME||'    '||SA_REC.PRODUCTNAME);

V_CNT := SA_CUR%ROWCOUNT;

END LOOP;

DBMS_OUTPUT.PUT_LINE('-------------------------');
DBMS_OUTPUT.PUT_LINE('전체 데이터 갯수 : '||TO_CHAR(V_CNT));
END;
 	
EXEC P_JEPUM('gg5595');

EXEC P_JEPUM('so1808');



CREATE OR REPLACE PROCEDURE P_SANO
(V_SANO NUMBER)
IS 
V_CNT NUMBER;

CURSOR SASU
IS
SELECT A.사수번호,B.사원명 사수명,A.사원번호,A.사원명
FROM 사원 A, 사원 B WHERE B.사원번호 = A.사수번호 AND A.사수번호 = V_SANO;

BEGIN
DBMS_OUTPUT.PUT_LINE('사수명   사수번호   사원번호   사원명');
DBMS_OUTPUT.PUT_LINE('-------------------------------------');

FOR SA_REC IN SASU LOOP

DBMS_OUTPUT.PUT_LINE(SA_REC.사수명||'    '||SA_REC.사수번호||'    '||SA_REC.사원번호||'    '||SA_REC.사원명);

V_CNT := SASU%ROWCOUNT;

END LOOP;

DBMS_OUTPUT.PUT_LINE('-------------------------');
DBMS_OUTPUT.PUT_LINE('전체 데이터 갯수 : '||TO_CHAR(V_CNT));
END;
 	
EXEC P_SANO(2004);

SELECT * FROM 사원;

--------------------------------------------------------

--PACKAGE
--PROCEDURE 묶음
--PACKAGE + BODY

--PAKAGE 생성
CREATE OR REPLACE PACKAGE SAWON_PACK
IS
PROCEDURE SANO_OUT;
PROCEDURE SANAME_OUT;
PROCEDURE JIK_OUT;
PROCEDURE PAY_OUT;
END;

--BODY 생성
CREATE OR REPLACE PACKAGE BODY SAWON_PACK
IS

CURSOR SW_CUR
IS
SELECT * FROM 사원;

PROCEDURE SANO_OUT
IS
BEGIN
DBMS_OUTPUT.PUT_LINE('사원번호');
DBMS_OUTPUT.PUT_LINE('--------');
FOR SW_REC IN SW_CUR LOOP
DBMS_OUTPUT.PUT_LINE(SW_REC.사원번호);
END LOOP;
END;

PROCEDURE SANAME_OUT
IS
BEGIN
DBMS_OUTPUT.PUT_LINE('사원명');
DBMS_OUTPUT.PUT_LINE('--------');
FOR SW_REC IN SW_CUR LOOP
DBMS_OUTPUT.PUT_LINE(SW_REC.사원명);
END LOOP;
END;

PROCEDURE JIK_OUT
IS
BEGIN
DBMS_OUTPUT.PUT_LINE('직급');
DBMS_OUTPUT.PUT_LINE('--------');
FOR SW_REC IN SW_CUR LOOP
DBMS_OUTPUT.PUT_LINE(SW_REC.직급);
END LOOP;
END;

PROCEDURE PAY_OUT
IS
BEGIN
DBMS_OUTPUT.PUT_LINE('급여');
DBMS_OUTPUT.PUT_LINE('--------');
FOR SW_REC IN SW_CUR LOOP
DBMS_OUTPUT.PUT_LINE(SW_REC.급여);
END LOOP;
END;

END;

--실행
EXEC SAWON_PACK.SANO_OUT;
EXEC SAWON_PACK.SANAME_OUT;
EXEC SAWON_PACK.JIK_OUT;
EXEC SAWON_PACK.PAY_OUT;


---------------------------------------------------------

--TRIGGER : 연쇄 반응, 작업 하나 하면 연쇄적으로 여러 작업들이 실행됨

--AFTER TRIGGER, 선입력 후검증
--BEFORE TRIGGER, 선검증 후입력

CREATE TABLE HAKSANG
(HAKBUN VARCHAR2(10),
NAME VARCHAR2(10));

CREATE TABLE MEMO
(NO NUMBER,
BIGO VARCHAR2(100));

CREATE SEQUENCE SE100
START WITH 1
INCREMENT BY 1
MAXVALUE 100
NOCYCLE
NOCACHE;

SELECT * FROM HAKSANG;
SELECT * FROM MEMO;

--AFTER TRIGGER
--만드는 순간 메모리 올라가서 실행
CREATE OR REPLACE TRIGGER TRI_HAKSANG_IN
AFTER INSERT --INSERT 된 후 실행
ON LEE.HAKSANG --스키마 써줘야됨
BEGIN
INSERT INTO MEMO VALUES(SE100.NEXTVAL,'행이 INSERT됨');
END;

INSERT INTO HAKSANG VALUES(111,'SUZI');

SELECT * FROM HAKSANG;
SELECT * FROM MEMO;


--FOR EACH ROW : 모든 레코드마다 트리거가 작동되는 행트리거

--FOR EACH ROW 내장변수
--:NEW : INSERT 되는 값, UPDATE된 후의 값에 접근 가능
--:OLD : UPDATE 되기전 값, DELETE 되기전 값에 접근 가능
CREATE OR REPLACE TRIGGER TRI_HAKSANG_IN
AFTER INSERT --INSERT 된 후 실행
ON LEE.HAKSANG --스키마 써줘야됨
FOR EACH ROW
BEGIN
INSERT INTO MEMO VALUES(SE100.NEXTVAL,:NEW.NAME||'행이 INSERT됨');
END;

INSERT INTO HAKSANG VALUES(222,'INNA');

SELECT * FROM HAKSANG;
SELECT * FROM MEMO;


--TRIGGER로 데이터 복사
CREATE TABLE COPY_HAKSANG
(HAKBUN VARCHAR2(10), NAME VARCHAR2(10));

CREATE OR REPLACE TRIGGER TRI_COPY_HAKSANG_IN
AFTER INSERT
ON LEE.HAKSANG
FOR EACH ROW
BEGIN
INSERT INTO COPY_HAKSANG VALUES (:NEW.HAKBUN, :NEW.NAME);
END;
 
INSERT INTO HAKSANG VALUES (333,'INSUN');

SELECT * FROM HAKSANG;
SELECT * FROM MEMO;
SELECT * FROM COPY_HAKSANG;


--UPDATE TRIGGER
CREATE OR REPLACE TRIGGER TRI_HAKSANG_UP
AFTER UPDATE OF NAME --NAME열이 수정됫을때만 실해
ON LEE.HAKSANG
FOR EACH ROW
BEGIN
INSERT INTO MEMO VALUES (SE100.NEXTVAL, :OLD.NAME||' 행이 '||:NEW.NAME||'로 UPDATE됨');
END;

UPDATE HAKSANG SET NAME='INSU' WHERE HAKBUN=111;


SELECT * FROM HAKSANG;
SELECT * FROM MEMO;
SELECT * FROM COPY_HAKSANG;


--DELETE TRIGGER
CREATE OR REPLACE TRIGGER TRI_HAKSANG_DEL
AFTER DELETE
ON LEE.HAKSANG
FOR EACH ROW
BEGIN
INSERT INTO MEMO VALUES (SE100.NEXTVAL, :OLD.NAME||' 행이 DELETE됨');

INSERT INTO COPY_HAKSANG VALUES(:OLD.HAKBUN, :OLD.NAME);
END;

DELETE HAKSANG WHERE HAKBUN=111;

SELECT * FROM HAKSANG;
SELECT * FROM MEMO;
SELECT * FROM COPY_HAKSANG;


-----------------------------
--BEFORE TRIGGER

CREATE TABLE INSA
(EMPNO NUMBER(4) PRIMARY KEY,
ENAME VARCHAR2(10),
JIK VARCHAR2(10),
SAL NUMBER);


--여기서 안됨, 왜 안되는지 모름,CMD ㄱㄱ
CREATE OR REPLACE TRIGGER TRI_INSA
BEFORE INSERT OR DELETE OR UPDATE
ON LEE.INSA

DECLARE

IMPOSSIBLE_TIME EXCEPTION;

BEGIN
IF TO_CHAR(SYSDATE,'DAY') IN ('토요일','일요일') OR TO_CHAR(SYSDATE,'HH24') < 12 OR TO_CHAR(SYSDATE,'HH24') >17 THEN
RAISE IMPOSSIBLE_TIME;
END IF;

EXCEPTION
WHEN IMPOSSIBLE_TIME THEN
RAISE_APPLICATION_ERROR(-20007,'월요일부터 금요일까지 정오 12:00 부터 오후 5시까지만 DML작업이 가능');
END;


SELECT * FROM INSA;

INSERT INTO INSA VALUES (7,'수지','과장',5000);

COMMIT;




CREATE TABLE MEMBER
(ID NUMBER(3) PRIMARY KEY,
NAME VARCHAR2(10),
JUBUN VARCHAR2(13));


--이거도 여기서 안됨, 아마 트리거 안에 익명PROCEDURE 변수 선언이 안되는거같음, CMD ㄱ
CREATE OR REPLACE TRIGGER TRI_MEMBER_JUBUN
BEFORE INSERT OR UPDATE OF JUBUN
ON LEE.MEMBER
FOR EACH ROW

DECLARE
A NUMBER; B NUMBER; C NUMBER; D NUMBER; E NUMBER; F NUMBER; G NUMBER; H NUMBER; I NUMBER; J NUMBER; K NUMBER; L NUMBER; M NUMBER; 
CK NUMBER;

JUBUNFAIL EXCEPTION;

BEGIN

A:=SUBSTR(:NEW.JUBUN,1,1);
B:=SUBSTR(:NEW.JUBUN,2,1);
C:=SUBSTR(:NEW.JUBUN,3,1);
D:=SUBSTR(:NEW.JUBUN,4,1);
E:=SUBSTR(:NEW.JUBUN,5,1);
F:=SUBSTR(:NEW.JUBUN,6,1);
G:=SUBSTR(:NEW.JUBUN,7,1);
H:=SUBSTR(:NEW.JUBUN,8,1);
I:=SUBSTR(:NEW.JUBUN,9,1);
J:=SUBSTR(:NEW.JUBUN,10,1);
K:=SUBSTR(:NEW.JUBUN,11,1);
L:=SUBSTR(:NEW.JUBUN,12,1);
M:=SUBSTR(:NEW.JUBUN,13,1);

CK:=(A*2)+(B*3)+(C*4)+(D*5)+(E*6)+(F*7)+(G*8)+(H*9)+(I*2)+(J*3)+(K*4)+(L*5);

CK:= MOD(CK,11);
CK:= 11-CK;
CK:=MOD(CK,10);

IF M != CK THEN 
RAISE JUBUNFAIL;
END IF;

EXCEPTION
WHEN JUBUNFAIL THEN
RAISE_APPLICATION_ERROR(-20001,'주민번호 틀림');
END;

INSERT INTO MEMBER VALUES('111','배수지','1111111111118');

INSERT INTO MEMBER VALUES('222','배수지','1111111111128');

SELECT * FROM MEMBER;

COMMIT;



































