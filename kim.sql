--kim
/*
1. query
   select data검색어

2. dml(data maipulation language)
    insert, update, delete
    
3. ddl(data difinition language)
    create, alter, drop, rename
    
4. tcl(transaction control language)
    truncation, commit, rollback, savepoint
    
5. dcl(data control language)
    grant, revoke
*/

--
select * from tab;

--주석

select * from personnel;
SELECT * from DIVISION;
SELECT * from PAYGRADE;
SELECT * from BONUS;

SELECT pname, pay,job,DNO,pno from PERSONNEL;

SELECT job from PERSONNEL;

--중복제거
SELECT DISTINCT job from PERSONNEL;

--pay기준으로 오름차순 정렬
SELECT * from PERSONNEL
ORDER by pay ASC;

--asc가 디폴트
SELECT * from PERSONNEL
ORDER by pname;

--내림차순 정렬
SELECT * from PERSONNEL
ORDER by pay DESC;

SELECT * from PERSONNEL
ORDER by startdate DESC;

--4번째 컬럼 기준 내림차순 정렬
SELECT * from PERSONNEL
ORDER by 4 DESC;

SELECT PNAME,job,STARTDATE,DNO from PERSONNEL
ORDER by 4 DESC;

--별칭, as 생략 가능
SELECT pno as 사원번호,pname as 이름,pay 월급 from PERSONNEL;

--파생 컬럼, 데이터 꺼내면서 연산가능
SELECT PNAME,pay,PAY+1000 보너스 FROM PERSONNEL;
SELECT PNAME,pay,PAY+1000 "보 너 스" FROM PERSONNEL;
SELECT PNAME,pay,PAY+1000 보_너_스 FROM PERSONNEL;

--ORDER BY 에서만 별칭 사용 가능
SELECT PNAME,pay,PAY+1000 보너스 FROM PERSONNEL
ORDER BY 보너스;
--보통 이렇게 씀
SELECT PNAME,pay,PAY+1000 보너스 FROM PERSONNEL
ORDER BY PAY+1000;

--NULL,정렬때 큰값으로 인식
SELECT * FROM PERSONNEL
ORDER BY MANAGER ASC;

SELECT * FROM PERSONNEL
ORDER BY MANAGER DESC;

--사원의 급여와 일년치 연봉을 구하시오
SELECT PNO,PNAME,PAY,JOB,PAY*12 AS 연봉 FROM PERSONNEL;

--컬럼 붙여서 보기
SELECT PNAME || PNO FROM PERSONNEL;
SELECT PNAME || ' ' ||PNO FROM PERSONNEL;

--NVL(A,B) A가 NULL이면 B출력
SELECT PAY,BONUS,NVL(BONUS*1.1,0) 인상분 FROM PERSONNEL;

--조건절(WHERE), 행제한
-- =, >= , <=, <>, >, <

--급여가 1600인 사원
SELECT * FROM PERSONNEL WHERE PAY = 1600;

--사번이 1116인 사원
SELECT * FROM PERSONNEL WHERE PNO = 1116;

--급여가 2000이하인 사원
SELECT * FROM PERSONNEL WHERE PAY <= 2000;

--90년 12월 17일에 입사한 사원
SELECT * FROM PERSONNEL WHERE STARTDATE = '1990-12-17';

SELECT * FROM NLS_SESSION_PARAMETERS;

--업무가 CLERK인 사원
SELECT * FROM PERSONNEL WHERE JOB = 'CLERK';

--이름이 JAMES인 사원
SELECT * FROM PERSONNEL WHERE PNAME = 'JAMES'; --O

SELECT * FROM PERSONNEL WHERE PNAME = 'james'; -- X


--논리연산자
--AND, OR, NOT

--부서번호가 10번이고 급여가 3000이상인 사원
SELECT * FROM PERSONNEL WHERE DNO = 10 AND PAY >= 3000;

--직업이 SALESMAN 이고 90년 이후에 입사한 사원
SELECT * FROM PERSONNEL WHERE JOB = 'SALESMAN' AND STARTDATE > '1990-12-31';

--부서번호가 10번이거나 급여가 3000이상인 사원
SELECT * FROM PERSONNEL WHERE DNO = 10 OR PAY >= 3000;

--직업이 SALESMAN 또는 90년 이후에 입사한 사원
SELECT * FROM PERSONNEL WHERE JOB = 'SALESMAN' OR STARTDATE > '1990-12-31';

--업무가 SALESMAN,CLERK이 아닌 사원
SELECT * FROM PERSONNEL WHERE NOT JOB = 'SALESMAN' AND NOT JOB = 'CLERK';

SELECT * FROM PERSONNEL WHERE JOB <> 'SALESMAN' AND JOB <> 'CLERK';

SELECT * FROM PERSONNEL WHERE JOB NOT IN('SALESMAN','CLERK');

--업무가 SALESMAN 또는 CLERK인 사원
SELECT * FROM PERSONNEL WHERE JOB IN('SALESMAN','CLERK');

--급여가 1000에서 2000인 사원
SELECT * FROM PERSONNEL WHERE PAY >= 1000 AND PAY < = 2000;

SELECT * FROM PERSONNEL WHERE PAY BETWEEN 1000 AND 2000;

SELECT * FROM PERSONNEL WHERE PAY BETWEEN 2000 AND 1000; --X

SELECT * FROM PERSONNEL WHERE STARTDATE BETWEEN '1991-01-01' AND '1991-09-30';

--부서번호가 20과 30 사이의 사원
SELECT * FROM PERSONNEL WHERE DNO IN (20,30); -- OR

SELECT * FROM PERSONNEL WHERE DNO BETWEEN 20 AND 30; -- 20 <= DNO <= 30


--이름이 A로 시작되는 사원
SELECT * FROM PERSONNEL WHERE PNAME LIKE 'A%';

SELECT * FROM PERSONNEL WHERE PNO LIKE '111%'; -- 앞자리 111 시작, 자릿수가 4자리 이상

SELECT * FROM PERSONNEL WHERE PNO LIKE '111_'; -- 앞자리 111 시작, 자릿수가 4자리

SELECT * FROM PERSONNEL WHERE PNO LIKE '1__1'; -- 앞뒷자리 1, 자릿수가 4자리

--90년도에 입사한 사원
SELECT * FROM PERSONNEL WHERE STARTDATE LIKE '90%';


/*
 .	: 임의의 한 문자
 |	: OR과 동일 (왼쪽 또는 오른쪽과 일치)
 []	: 문자 클래스
 [-] : 문자 범위 (0-9, a-z, A-Z, 가-힝)
 [^] : 부정 문자 클래스
  ^	: 문자열의 시작과 일치
 \	: 다음에 오는 문자를 이스케이프 (메타 문자를 일반 문자로)
 $	: 문자열의 끝과 일치
*/

--정규화 표현식
SELECT * FROM PERSONNEL WHERE REGEXP_LIKE (PNO, '11[^2]');
-- '^JO' == LIKE 'JO%'
SELECT * FROM PERSONNEL
WHERE REGEXP_LIKE(PNAME,'^JO|^JA') ;

--이메일에서 아이디 추출
SELECT REGEXP_SUBSTR('GILDONG@NAVER.COM','[^@]+') 아이디 FROM DUAL;

SELECT * FROM DUAL;

--O_K를 포함한 이름을 가진 사원
SELECT * FROM PERSONNEL;

INSERT INTO PERSONNEL VALUES (2000,'HELLO_KIM','SALESMAN',1116,'2025-7-22',5000,'',20);

INSERT INTO PERSONNEL VALUES (3000,'HELLOZKIM','SALESMAN',1116,'2025-7-22',5000,'',20);
--HELLO_KIM
SELECT * FROM PERSONNEL WHERE PNAME LIKE '%O\_K%' ESCAPE '\';

--DELETE
DELETE PERSONNEL WHERE PNO IN (2000,3000);

SELECT * FROM PERSONNEL;
--DB 변경하고 COMMIT해서 저장 해야됨
COMMIT;


--NULL
SELECT * FROM PERSONNEL;

SELECT * FROM PERSONNEL WHERE MANAGER = NULL; --X

SELECT * FROM PERSONNEL WHERE MANAGER = 'NULL'; --X

SELECT * FROM PERSONNEL WHERE MANAGER IS NULL; --O

SELECT * FROM PERSONNEL WHERE MANAGER IS NOT NULL; --O


--업무가 MANAGER고 급여가 1500이상인 사원 또는 업무가 SALESMAN인 사원을 검색
SELECT * FROM PERSONNEL WHERE (JOB = 'MANAGER' AND PAY >= 1500) OR JOB = 'SALESMAN';


--함수

--숫자함수

--ROUND : 반올림
--  1  2  3  4  .  5  6  7
-- -4 -3 -2 -1  0  1  2  3
-- 2의 자릿수에서 반올림해라
SELECT ROUND(45.275, 1) FROM DUAL;--45.3
---1의 자릿수에서 반올림해라
SELECT ROUND(45.275, -1) FROM DUAL;--50
--0의 자릿수에서 반올림해라
SELECT ROUND(45.275, 0) FROM DUAL;--45
--소숫점 반올림해서 정수만
SELECT ROUND(45.275) FROM DUAL;--45

SELECT PNO,PNAME,PAY,ROUND(PAY,-2) FROM PERSONNEL;

--TRUNC : 절삭
--  1  2  3  4  .  5  6  7
-- -4 -3 -2 -1  0  1  2  3
SELECT TRUNC(45.245,2) FROM DUAL;--45.24

SELECT TRUNC(45.245,-1) FROM DUAL;--40

--CEIL/FLOOR(올림/내림), 양수만 반환
SELECT CEIL(461.21) FROM DUAL; --462
SELECT CEIL(461.91) FROM DUAL; --462

SELECT FLOOR(461.21) FROM DUAL; --461
SELECT FLOOR(461.91) FROM DUAL; --461

--MOD : 나머지
SELECT MOD(10,3) FROM DUAL;--1

-- ABS : 절대값
SELECT ABS(-123) FROM DUAL;--123

--SIGN : 결과값 양수면 1, 음수면 -1, 0이면 0 반환
SELECT SIGN(100/30),SIGN(-100/30),SIGN(100-100) FROM DUAL;

--POWER : 지수
SELECT POWER(2,4) FROM DUAL;

--SQRT : 제곱근
SELECT SQRT(9) FROM DUAL;


--문자함수
--UPPER : 소문자 -> 대문자
SELECT UPPER('oracle') FROM DUAL;

--LOWER : 대문자 -> 소문자
SELECT LOWER('ORACLE') FROM DUAL;

SELECT * FROM DIVISION;
SELECT * FROM DIVISION WHERE DNAME = UPPER('sales');
SELECT * FROM DIVISION WHERE LOWER(DNAME)= 'sales';

--INITCAP, 첫글자 대문자 변경
SELECT INITCAP('korea fighting') FROM DUAL;

--CONCAT, 문장 붙이기
SELECT PNAME || DNO FROM PERSONNEL;
SELECT CONCAT('KOREA','FIGHTING') FROM DUAL;

--LENGTH, 공백도 셈
SELECT LENGTH('KOREA') FROM DUAL;
SELECT LENGTH('KOREA FIGHTING') FROM DUAL;

--SUBSTR, 문자 추출
SELECT SUBSTR('ABCDEFG',1,3) FROM DUAL;--ABC
SELECT SUBSTR('ABCDEFG',3,2) FROM DUAL;--CD
SELECT SUBSTR('ABCDEFG',-3,2) FROM DUAL;--EF
SELECT SUBSTR('ABCDEFG',-4) FROM DUAL;--DEFG

--INSTR : 인덱스 번호
SELECT INSTR('ABCDEFG','C') FROM DUAL;--3
SELECT INSTR('AAAAAAA','A') FROM DUAL;--1, 첫번째것만 찾음
SELECT INSTR('ABCDEFG','a') FROM DUAL;--0

--RPAD/LPAD 
SELECT RPAD(PNAME,15,'*') FROM PERSONNEL;--15자에 오른쪽 남는자리에 *로 채움
SELECT LPAD(PNAME,15,'*') FROM PERSONNEL;--15자에 왼쪽 남는자리에 *로 채움

--RTRIM/LTRIM : 문자, 공백 지우기
SELECT RTRIM('ABBBBB','B') FROM DUAL;
SELECT RTRIM('A     ',' ') FROM DUAL;

SELECT RTRIM('BBABBB','B') FROM DUAL;
SELECT LTRIM('BBABBB','B') FROM DUAL;


--날짜함수

--SYSDATE, 연산가능
SELECT * FROM DUAL;
SELECT SYSDATE FROM DUAL; -- GETDATE()
SELECT SYSDATE+10 FROM DUAL;
SELECT STARTDATE-1,STARTDATE,STARTDATE+1 FROM PERSONNEL;

--KIM사원이 현재까지 근무한 년수를 구하시오
SELECT * FROM PERSONNEL;
SELECT PNAME,STARTDATE,(SYSDATE - STARTDATE) 근무일수 FROM PERSONNEL;
SELECT PNAME,STARTDATE,ROUND((SYSDATE - STARTDATE)/365) || '년차' 근무년수 FROM PERSONNEL WHERE PNAME = 'KIM';

--ROUND, 날짜 반올림
SELECT STARTDATE,ROUND(STARTDATE,'YEAR') FROM PERSONNEL; 

SELECT STARTDATE,ROUND(STARTDATE,'YEAR'),ROUND(STARTDATE,'MONTH') FROM PERSONNEL; 

--TO_CHAR : 날짜 문자열 변환,포맷가능
SELECT TO_CHAR(SYSDATE,'YY-MM-DD HH24:MI') FROM DUAL;

--TRUNC
SELECT STARTDATE,TRUNC(STARTDATE,'YEAR'),TRUNC(STARTDATE,'MONTH') FROM PERSONNEL; 

--달수 구하기 , MONTHS_BETWEEN
SELECT MONTHS_BETWEEN(SYSDATE,'2002-06-01') FROM DUAL;--277달차이
SELECT TRUNC(MONTHS_BETWEEN(SYSDATE,'2002-06-01')/12) NALSU FROM DUAL;

--EXTRACT : 날짜 추출
SELECT STARTDATE ,EXTRACT(YEAR FROM STARTDATE) 년, EXTRACT(MONTH FROM STARTDATE) 월, EXTRACT(DAY FROM STARTDATE) 일 FROM PERSONNEL;

--달의 마지막날
SELECT STARTDATE, LAST_DAY(STARTDATE) FROM PERSONNEL;

--NEXT_DAY : 다음 요일 반환
SELECT NEXT_DAY('2025-07-22', '금요일') FROM DUAL;
SELECT NEXT_DAY(SYSDATE, '화요일') FROM DUAL;

--달 더하기
SELECT ADD_MONTHS(SYSDATE,24) FROM DUAL;


--변환함수
/*
MM : 달수
MON : 3문자의 달 이름 (MAR)
MONTH : 달의 풀네임 (MARCH)
DD : 달의 날짜수(22)
D : 주의 수(1~7)
DY : 3문자의 요일이름(MON)
DAY : 일의 풀네임(MONDAY)
YYYY : 2025
YY : 25
RM : 로마식 달수(VII)
*/

SELECT SYSDATE, TO_CHAR(SYSDATE,'D') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE,'DY') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE,'MONTH') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE,'YYYY') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE,'DD') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE,'YY MM DD') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE,'RM') FROM DUAL;

SELECT PNAME,TO_CHAR(STARTDATE,'FMDD-MON-YY') STARTDATE1 ,TO_CHAR(STARTDATE,'DD-MON-YY') STARTDATE2 FROM PERSONNEL;


--시간
/*
HH,HH12 : 12시간
HH24 : 24시간
MI : 분
SS : 초
SSSSS : 초의 자릿수
AM,PM,A.M,P.M : 오전, 오후
*/

SELECT TO_CHAR(SYSDATE, 'HH24:MI:SS') FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'A.M. HH:MI:SS') FROM DUAL;


--숫자형식
/*
9 : 숫자 자릿수
0 : 자릿수가 비면 0으로 채움
$ : 달러기호
PR : 음수표시
. , : 천단위 표시
*/

SELECT TO_CHAR(PAY,'$09,999.9') FROM PERSONNEL; 

SELECT TO_CHAR(-1000,'09,999PR') FROM DUAL;-- <숫자>는 음수표시

--서수표시
SELECT SYSDATE, TO_CHAR(SYSDATE,'DD') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE,'DDSP') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE,'DDTH') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE,'DDSPTH') FROM DUAL;

--TO_DATE : 문자열 날짜로 변경
SELECT TO_DATE('12-6월-23 11:05:22','YY-MONTH-DD HH:MI:SS') FROM DUAL;

--TO_NUMBER : 숫자로 변경
SELECT TO_NUMBER('123')+100 FROM DUAL;

SELECT TO_NUMBER('ABC')+100 FROM DUAL;--X

--NVL
SELECT BONUS,NVL(BONUS,0) FROM PERSONNEL;
SELECT MANAGER, NVL(TO_CHAR(MANAGER),'NO-MANAGER') FROM PERSONNEL;

--테이블 정보
DESCRIBE PERSONNEL;
DESC PERSONNEL;

--DECODE : IF문, 등호 연산만 가능
--각 사원의 급여를 부서가 10인 경우 10%, 20인 경우 20%, 나머지는 30%를 더해서 출력
SELECT PNAME,BONUS,DNO,PAY,DECODE(DNO,10,PAY*1.1,20,PAY*1.2,PAY*1.3) 인상분 FROM PERSONNEL;

--급여가 3500이상인 경우에는 GRADE를 'GOOD', 미만인 경우에는 'POOR'를 출력
SELECT PNAME,PAY FROM PERSONNEL WHERE PAY >= 3500;

SELECT PNAME,PAY,DECODE(SIGN(PAY-3500),1,'GOOD',0,'SOSO','POOR') GRADE FROM PERSONNEL;

------------------------------------------------------------------------------------
--그룹함수

--결과가 한개만 출력, 단일값 출력, 다중값 출력하는거랑 같이 못씀

--COUNT : 해당 칼럼의 행 갯수셈, NULL은 카운트 안함
SELECT * FROM PERSONNEL;
SELECT COUNT(*) FROM PERSONNEL;
SELECT COUNT(MANAGER) FROM PERSONNEL;
SELECT COUNT(BONUS) FROM PERSONNEL;

-- 급여가 3000이상인 사원 수
SELECT COUNT(*) FROM PERSONNEL WHERE PAY >= 3000;

--AVG :칼럼의 평균
SELECT AVG(PAY) FROM PERSONNEL;

--보너스의 평균
SELECT AVG(NVL(BONUS,0)) BONUS_AVG FROM PERSONNEL;

--SUM : 칼럼의 합계
SELECT SUM(PAY) FROM PERSONNEL;

--MAX/MIN : 최대/최솟값
SELECT MAX(PAY),MIN(PAY) FROM PERSONNEL;

--사원중에 입사한지 가장 오래된 사원
SELECT MIN(STARTDATE) FROM PERSONNEL;

--가장 오래된 사원과 신입의 연차
SELECT ROUND((MAX(STARTDATE)-MIN(STARTDATE))/365) YEAR FROM PERSONNEL;


--분석 함수

--부서별 평균 ,OVER(PARTITION BY 컬럼) : 특정 컬럼 그룹별 계산 
SELECT * FROM PERSONNEL;
SELECT DISTINCT(DNO),AVG(PAY) OVER(PARTITION BY DNO) B_AVG FROM PERSONNEL ORDER BY DNO;


SELECT * FROM PERSONNEL;
--RANK : 순위
--월급 전체 순위
SELECT PNAME,PAY, RANK() OVER(ORDER BY PAY DESC) RANK FROM PERSONNEL;
--월급을 1200 받는 사람 순위
SELECT RANK(1200) WITHIN GROUP(ORDER BY PAY DESC) "1200_RANK" FROM PERSONNEL;

--GROUP BY 컬럼 : 컬럼으로 그룹지움
--부서별 평균 급여
SELECT DNO, AVG(PAY) FROM PERSONNEL GROUP BY DNO ORDER BY DNO;

--직업별 평균급여,인원수 구하기
SELECT JOB, ROUND(AVG(PAY)) AVG,COUNT(*) CNT FROM PERSONNEL GROUP BY JOB ORDER BY AVG;

--각 부서의 평균이 전체 평균보다 많으면 GOOD, 아니면 POOR
SELECT DNO,ROUND(AVG(PAY)),DECODE(SIGN(AVG(PAY)-(SELECT AVG(PAY) FROM PERSONNEL)),1,'GOOD','POOR') GRADE 
FROM PERSONNEL GROUP BY DNO;

--SELECT의 조건문은 WHERE, GROUP BY의 조건문은 HAVING, HAVING은 별칭 사용 불가
SELECT DNO,ROUND(AVG(PAY)),DECODE(SIGN(AVG(PAY)-(SELECT AVG(PAY) FROM PERSONNEL)),1,'GOOD','POOR') GRADE 
FROM PERSONNEL GROUP BY DNO HAVING AVG(PAY) >= 3500;

------------------------------------------------------------------------------------
--SELF JOIN
SELECT * FROM PERSONNEL;
--사원 매니저 찾기
SELECT A.PNO 사원번호,A.PNAME 사원이름,B.PNO 관리자번호, B.PNAME 관리자이름 
FROM PERSONNEL A,PERSONNEL B WHERE A.MANAGER=B.PNO;

----------------------------------------------------------------------------------
--NON EQUI JOIN, 데이터가 정확하게 일치 하지않을때 사용, 범위등
SELECT * FROM PERSONNEL;
SELECT * FROM PAYGRADE;

--GRADE의 등급범위에 속하는 PERSONNEL의 PAY의 등급
SELECT PNAME,PAY,B.GRADE
FROM PERSONNEL A, PAYGRADE B 
WHERE PAY BETWEEN LOWPAY AND HIGHPAY;


--MINUS, 빼기
SELECT DNO FROM PERSONNEL;--10,20,30

SELECT DNO FROM DIVISION;--10,20,30,40

SELECT DNO FROM DIVISION
MINUS
SELECT DNO FROM PERSONNEL;--40

--INTERSECT, 교집합
SELECT DNO FROM DIVISION
INTERSECT
SELECT DNO FROM PERSONNEL;--10,20,30

------------------------------------------------------------------------

--PAIRWISE
--PERSONNEL의 PAY와 BONUS 동시에 비교해서 가져옴
SELECT PNAME,DNO,PAY,BONUS FROM PERSONNEL 
WHERE (PAY,BONUS) IN (SELECT PAY,BONUS FROM PERSONNEL WHERE DNO = 30);

SELECT PAY,BONUS FROM PERSONNEL WHERE DNO = 30;

--NON PAIRWISE
--이게 근본
SELECT PNAME,DNO,PAY,BONUS FROM PERSONNEL 
WHERE PAY IN (SELECT PAY FROM PERSONNEL WHERE DNO = 30)
AND BONUS IN (SELECT BONUS FROM PERSONNEL WHERE DNO = 30);

---------------------------------------------------------

--DML (INSERT, UPDATE,DELETE)

SELECT * FROM TAB;

--테이블 생성
CREATE TABLE MANAGER
AS SELECT * FROM PERSONNEL
WHERE 1=2; -- 거짓값, 데이터 구조만 복사해옴

SELECT * FROM MANAGER;

CREATE TABLE SALESMAN
AS SELECT * FROM PERSONNEL
WHERE 1=2;

CREATE TABLE BUSEO
AS SELECT * FROM DIVISION;

SELECT * FROM BUSEO;

CREATE TABLE SAWON
AS SELECT * FROM PERSONNEL;

CREATE TABLE EXAM1
AS SELECT * FROM PERSONNEL;

CREATE TABLE EXAM2
AS SELECT * FROM DIVISION;

SELECT * FROM TAB;

SELECT * FROM DIVISION;
DESC DIVISION;

--데이터 삽입
INSERT INTO DIVISION VALUES(50,'OPERATION','031-1234-1234','SUWON');

SELECT * FROM DIVISION;

INSERT INTO DIVISION VALUES(60);--X,데이터 갯수 안맞음

INSERT INTO DIVISION (DNO) VALUES(60);--O , DNO빼고 나머지는 자동으로 NULL 들어감

SELECT * FROM DIVISION;

--PRIMARY KEY : 중복 X, NULL X, 테이블에 1개만 존재
--오류보면 DNO에는 NULL값 못들어가게 설계되있음, PRIMARY KEY임
INSERT INTO DIVISION (DNAME,POSITION) VALUES('ACCOUNT','DAEJUN');--X

SELECT * FROM DIVISION;
DESC DIVISION;

--DICTIONARY
SELECT * FROM USER_CONSTRAINTS; -- 제약조건 보여줌


INSERT INTO PERSONNEL (PNO,PNAME,PAY,DNO) VALUES(7711,'YOUNG',4000,20);

SELECT * FROM PERSONNEL;

--명시적 NULL삽입
INSERT INTO DIVISION VALUES(90,'SERVICE','32-3456-6789',NULL);
INSERT INTO DIVISION VALUES(90,'SERVICE','32-3456-6789','');

SELECT * FROM DIVISION;

SELECT SYSDATE FROM DUAL;

--오늘날짜 삽입
INSERT INTO PERSONNEL (PNO,PNAME,JOB,STARTDATE,DNO) VALUES (1304,'SUZI','SALESMAN',SYSDATE,10);

SELECT * FROM PERSONNEL;

SELECT PNO,PNAME,TO_CHAR(STARTDATE,'YYYY-MM-DD') 가입일 FROM PERSONNEL WHERE PNAME = 'SUZI';


--치환변수 :쿼리박스에서 지원안함
--& :한번 치환하면 못바꿈
--&& : #UNDEFINE COL_NAME로 지우고 계속 바꿈

SELECT * FROM DIVISION;
DESC DIVISION;

SELECT PNO,PNAME,JOB,STARTDATE,DNO FROM PERSONNEL WHERE DNO = &DIV_NO;

SELECT PNO,PNAME,JOB,&&COL_NAME FROM PERSONNEL ORDER BY &ORDER_COL;-


SELECT * FROM MANAGER;

SELECT * FROM PERSONNEL WHERE JOB='MANAGER';

INSERT INTO MANAGER(PNO,PNAME,PAY,STARTDATE) SELECT PNO,PNAME,PAY,STARTDATE FROM PERSONNEL WHERE JOB = 'MANAGER';

SELECT * FROM MANAGER;

SELECT * FROM SALESMAN;

INSERT INTO SALESMAN SELECT * FROM PERSONNEL WHERE JOB = 'SALESMAN';

SELECT * FROM SALESMAN;

SELECT * FROM PERSONNEL;

DESC PERSONNEL;
--PK는 복사 안됨
DESC SALESMAN;

----------------------------------------------------

--UPDATE
--조건문 필수, 안쓰면 전부다 바뀜
SELECT * FROM PERSONNEL;

UPDATE PERSONNEL SET JOB ='CLERK',MANAGER=1001,STARTDATE=SYSDATE,BONUS=100 
WHERE PNO=7711;

COMMIT;
SELECT * FROM PERSONNEL;


SELECT * FROM DIVISION;

UPDATE DIVISION SET POSITION='SEOUL';
--마지막 커밋까지 롤백됨
ROLLBACK;

--DELETE
SELECT * FROM PERSONNEL WHERE PNO=7711;
--FROM 생략 가능
DELETE FROM PERSONNEL WHERE PNO=7711;
DELETE PERSONNEL WHERE PNO=1111;

SELECT * FROM PERSONNEL

SELECT * FROM DIVISION;

--조건문 없으면 다지움
DELETE PERSONNEL;
SELECT * FROM PERSONNEL;

ROLLBACK;


--DML(INSERT,UPDATE,DELETE)문장 실행시 에러,SELECT는 쿼리
--CRUD(INSERT,SELECT,UPDATE,DELETE)

SELECT * FROM PERSONNEL;

--INSERT에러
--제약조건(CONSTRAINT)에러,(PK)
INSERT INTO PERSONNEL(PNO,PNAME,DNO) VALUES(7711,'SONG',99);


--UPDATE에러(FK),DIVISION.DNO는PK, PERSONNEL.DNO는 DIVISION.DNO를 참조하는 FK
SELECT * FROM DIVISION;
SELECT * FROM PERSONNEL;
--DIVISION.DNO에 없는값 넣어서 에러
INSERT INTO PERSONNEL(PNO,DNO) VALUES (1000,99);
--제약조건 확인
SELECT * FROM USER_CONSTRAINTS;
--DIVISION.DNO에 없는값 수정해서 에러
UPDATE PERSONNEL SET DNO=20 WHERE PNO=1111;--O
UPDATE PERSONNEL SET DNO=66 WHERE PNO=1111;--X


--DELETE 에러
SELECT * FROM DIVISION;
SELECT * FROM PERSONNEL;
--FK가 참조하고있는 값은 삭제불가, 에러
DELETE DIVISION WHERE DNO =10;--X
--참조 안하고있는 값은 삭제 가능
DELETE DIVISION WHERE DNO =60;--O

-----------------------------------------------------------

--TRANSACTION : 작업이 이루어지는 단위
--COMMIT, ROLLBACK으로 트랜잭션 단위로 작업 확정, 취소함
--같은 트랜잭션 내에서 문제가 발생해, DML 명령문 중의 하나가 확정되지 못한다면 같은 트랜잭션의 다른 명령문 전부 취소됨

--TRANSACTION ROCK
--같은 테이블 쓰는 계정 여러개중 DML로 먼저 실행한 쪽이 락을 걸어 다른 계정을 COMMIT,ROLLBACK하기 전까지 사용 못하게 멈춰놈
commit;

--자체적으로 COMMIT을 시키는 경우
--AUTO COMMIT
--DDL(CREATE,ALTER,DROP,RENAME)
--DCL(GRANT,REVOKE)
--정상적이 종료시(EXIT)
--자바같은 언어에서 DML시켰을때
--AUTO ROLLBACK
--비정상적인 종료시(POWER OFF)

----------------------------------------------------------------------------------------

--DDL(CREATE,ALTER,DROP,RENAME)

--CREATE
--OBJECT(TABLE,INDEX,SEQUENCE,VIEW,SYNONYM)

--TABLE
--DATA TYPE
--CHAR : 문자(고정길이)
--VARCHAR2 : 문자(가변길이)
--NUMBER(P,S) : 숫자(가변길이)
--DATE : 날짜(고정길이(7BYTE))
--LONG : 문자(가변길이,2GB)
/*
1.영문자 시작(30자)
2.영문자,숫자 사용가능(공백허용안함)
3.특수문자는 _,$,#만 사용가능
4.이름은 중복허용안함
5.컬럼명이 틀려야함
6.예약어 사용못함

--사용가능한 이름
Sawon,P_NO,Division10,Name_Rule

--사용불가능한 이름
10division, $sal, p-no, Alter
*/

CREATE TABLE BUSEO1 
(DNO NUMBER(2),DNAME VARCHAR2(14),ZIPCODE CHAR(7));

SELECT * FROM BUSEO1;
DESC BUSEO1;

INSERT INTO BUSEO1 VALUES(1,'ACCOUNT','123-456');

SELECT * FROM BUSEO1;


CREATE TABLE CUSTOM
(ID NUMBER(2) PRIMARY KEY, NAME CHAR(10) NOT NULL,JUMIN CHAR(14),ZIP CHAR(7),ADDR VARCHAR2(50));

DESC CUSTOM;

INSERT INTO CUSTOM (ID,NAME,JUMIN,ZIP,ADDR) VALUES (10,'SUZI','941010-2123456','123-456','서울 어딘가');

INSERT INTO CUSTOM (ID,NAME,JUMIN,ZIP,ADDR) VALUES (20,'','941010-2123456','123-456','서울 어딘가');--X

SELECT * FROM CUSTOM;

SELECT * FROM USER_CONSTRAINTS;


CREATE TABLE CUSTOM_COPY
AS SELECT * FROM CUSTOM; -- PK는 복사 안됨, NOT NULL은 됨

DESC CUSTOM_COPY; 


CREATE TABLE PAY3000
AS SELECT * FROM PERSONNEL WHERE PAY > 3000;

SELECT * FROM PAY3000;


--PERSONNEL 테이블에서 12월달에 입사한 사원의 데이터를 MON12라는 테이블로 복사
SELECT * FROM PERSONNEL;

CREATE TABLE MON12
AS SELECT * FROM PERSONNEL WHERE TO_CHAR(STARTDATE,'MM') = '12';

SELECT * FROM MON12;

--테이블 생성시 컬럼명 변경
CREATE TABLE ANALYST(NUM,NAME,JOB,DNUM)
AS SELECT PNO,PNAME,JOB,DNO FROM PERSONNEL WHERE JOB='ANALYST';

SELECT * FROM ANALYST;


CREATE TABLE DIV10
AS SELECT DNO,SUM(PAY) SUM_PAY FROM PERSONNEL
GROUP BY DNO HAVING DNO=10;

SELECT * FROM DIV10;

----------------------------------------------------------

--테이블 수정
--ADD,MODIFY,DROP

CREATE TABLE SALESMAN1 AS SELECT PNO,PNAME,JOB,PAY FROM PERSONNEL WHERE JOB = 'SALESMAN';

SELECT * FROM SALESMAN1;
DESC SALESMAN1;

--컬럼 추가
ALTER TABLE SALESMAN1 ADD DNO NUMBER(2);

SELECT * FROM SALESMAN1;
DESC SALESMAN1;

INSERT INTO SALESMAN1 VALUES(1111,'NICK','SALESMAN',5000,20);
SELECT * FROM SALESMAN1;

ALTER TABLE SALESMAN1 ADD (JUMIN CHAR(14), ZIP CHAR(7));

SELECT * FROM SALESMAN1;
DESC SALESMAN1;
--컬럼만들때 기본값 추가,제약조건
ALTER TABLE SALESMAN1 ADD BIGO VARCHAR2(10) DEFAULT('AA');

SELECT * FROM SALESMAN1;
DESC SALESMAN1;

--CHECK KEY, 조건에 해당하는 값만 들어감
ALTER TABLE SALESMAN1 ADD (MARRIAGE CHAR(8) CONSTRAINT SALESMAN1_MARRIAGE_CK CHECK (MARRIAGE IN('SINGLE','MARRIED')));
INSERT INTO SALESMAN1 VALUES(2222,'INNA','SALESMAN',4000,20,'1111','1111','BB','SINGLE');

SELECT * FROM SALESMAN1;
DESC SALESMAN1;
--에러, CHECK키 제한조건에 해당하지 않음
INSERT INTO SALESMAN1 VALUES(3333,'INNA','SALESMAN',4000,20,'1111','1111','BB','SOLO');--X

INSERT INTO SALESMAN1 VALUES(3333,'INNA','SALESMAN',4000,20,'1111','1111','BB','MARRIED');--O

SELECT * FROM SALESMAN1;
DESC SALESMAN1;

--PK추가
ALTER TABLE SALESMAN1 ADD CONSTRAINT SALESMAN1_PNO_PK PRIMARY KEY (PNO);

DESC SALESMAN1;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME='SALESMAN1';


--MODIFY
CREATE TABLE MANAGER1 AS SELECT * FROM PERSONNEL WHERE JOB = 'MANAGER';

SELECT * FROM MANAGER1;

ALTER TABLE MANAGER1 ADD CONSTRAINT MANAGER1_PNO_PK PRIMARY KEY (PNO);

DESC MANAGER1;

ALTER TABLE MANAGER1 MODIFY PNAME VARCHAR2(16);

DESC MANAGER1;

--에러, 이미 있는 값이 5BYTE보다 큼,
ALTER TABLE MANAGER1 MODIFY PNAME VARCHAR2(5);--X
SELECT * FROM MANAGER1;

--DROP(삭제)
SELECT * FROM USER_CONSTRAINTS;
--둘다 됨
ALTER TABLE MANAGER1 DROP CONSTRAINT MANAGER1_PNO_PK;--0
ALTER TABLE MANAGER1 DROP PRIMARY KEY;--0

SELECT * FROM DIVISION;
--에러, 참조하고있는 FK가 존재
ALTER TABLE DIVISION DROP PRIMARY KEY;--X
--CASCADE : 강제, 참조하고있는 FK도 강제삭제
ALTER TABLE DIVISION DROP PRIMARY KEY CASCADE;

SELECT * FROM USER_CONSTRAINTS;
--PK삭제되서 중복값 들어감
SELECT * FROM DIVISION;
INSERT INTO DIVISION (DNO) VALUES (10);
--FK삭제되서 DIVISION에 없는값도 들어감
SELECT * FROM PERSONNEL;
INSERT INTO PERSONNEL (PNO,DNO) VALUES (1010,99);


--컬럼 삭제
SELECT * FROM SALESMAN1;
DESC SALESMAN1;

ALTER TABLE SALESMAN1 DROP COLUMN MARRIAGE;
SELECT * FROM SALESMAN1;

--SET UNUSED
--삭제된거처럼 사용 못하게함,업무중 사용
ALTER TABLE SALESMAN1 SET UNUSED COLUMN DNO;
SELECT * FROM SALESMAN1;
--UNUSED삭제,심야때 사용
ALTER TABLE SALESMAN1 DROP UNUSED COLUMNS;

--------------------------------------------------
--CREATE
--ALTER(ADD,MODIFY,DROP)
--DROP

--DROP
--테이블 삭제, 오라클 휴지통에 들어감

SELECT * FROM MANAGER1;
DROP TABLE MANAGER1;
--휴지통 확인
SELECT OBJECT_NAME,ORIGINAL_NAME,DROPTIME FROM RECYCLEBIN;
--휴지통에서 복원, 밑에 둘다 가능
FLASHBACK TABLE MANAGER1 TO BEFORE DROP;
FLASHBACK TABLE "BIN$nGgPPuWjRRmr9lWMTr1eLA==$0" TO BEFORE DROP;

SELECT * FROM MANAGER1;

DROP TABLE MANAGER1;
SELECT OBJECT_NAME,ORIGINAL_NAME,DROPTIME FROM RECYCLEBIN;
--휴지통에있는 테이블 내용확인
SELECT * FROM "BIN$1dMpGBNkSKuTjMb+NVrXiA==$0";
--휴지통 비우기
PURGE RECYCLEBIN;
--휴지통 거치지않고 바로 삭제
DROP TABLE SALESMAN1 PURGE;


--------------------------------------
--DROP TABLE ABC CASCADE;
--DROP USER ABC CASCADE;
--ABC가 만든 모든 데이터 삭제
--CASCADE없으면 계정만 삭제하고 데이터는 남아있음


--TRUNCATE/DELETE : 레코드삭제
COMMIT;
SELECT * FROM PERSONNEL;
--PERSONNEL 레코드 전부 삭제, TRANSACTION 시작
DELETE PERSONNEL;

SELECT * FROM PERSONNEL;

ROLLBACK;

SELECT * FROM PERSONNEL;

--롤백해도 못살려냄,대신 속도 빠름
TRUNCATE TABLE PERSONNEL;

SELECT * FROM PERSONNEL;

ROLLBACK;

SELECT * FROM PERSONNEL;


--RENAME
SELECT * FROM TABS;

SELECT * FROM PAY3000;

RENAME PAY3000 TO HIGHPAY;

SELECT * FROM TABS;

SELECT * FROM HIGHPAY;


--COMMENT, 테이블의 주석보여줌
SELECT * FROM USER_TAB_COMMENTS;
--주석 추가
COMMENT ON TABLE HIGHPAY IS '월급을 3000이상 많이 받는 사람들 정보';

SELECT * FROM USER_TAB_COMMENTS;

--시스템이쓰는 주석
SELECT * FROM ALL_TAB_COMMENTS;--테이블
SELECT * FROM ALL_COL_COMMENTS;--컬럼

--컬럼 주석 달기
COMMENT ON COLUMN HIGHPAY.JOB IS '월급 많이 받는 직원의 직업';
--컬럼의 주석 보여줌
SELECT * FROM USER_COL_COMMENTS WHERE TABLE_NAME='HIGHPAY';--컬럼

--주석 초기화
COMMENT ON TABLE HIGHPAY IS '';

COMMENT ON COLUMN HIGHPAY.JOB IS '';

select * FROM TAB;


CREATE USER ABC
IDENTIFIED BY 123
DEFAULT TABLESPACE USERS
TEMPORARY TABLESPACE TEMP;


SELECT * FROM USER_TAB_PRIVS_MADE;

--OBJECT 권한 주기
GRANT SELECT ON PERSONNEL TO TEST;

GRANT SELECT,INSERT,DELETE ON DIVISION TO TEST;

--권한 회수
REVOKE SELECT ON PERSONNEL FROM TEST;
REVOKE SELECT,INSERT,DELETE ON DIVISION FROM TEST;

SELECT * FROM USER_TAB_PRIVS_MADE;


--ROLE(역할), 권한 담는 그릇, 자기가 받은 롤 다른 유저한테 줄수있음
SELECT * FROM USER_ROLE_PRIVS;--어떤 롤 받았는지 확인

SELECT * FROM ROLE_SYS_PRIVS;--롤 안에 어떤 권한 있는지 확인

--VIEW만들기,ROLE은 나갓다 들어와야 적용됨
CREATE VIEW PER10
AS SELECT * FROM PERSONNEL WHERE DNO=10;

--ROLE 뺏기
REVOKE MANAGER FROM KIM;

------------------------------------------------------------------------------
--제약조건

--PRIMARY KEY
--COLUMN LEBEL방식
CREATE TABLE CUSTOMER (ID NUMBER(4) CONSTRAINT CUSTOMER_ID_PK PRIMARY KEY, NAME VARCHAR2(10), NO NUMBER(4));

DESC CUSTOMER;
SELECT * FROM CUSTOMER;

--TABLE LEBEL방식
CREATE TABLE ORDERS (NO NUMBER(4),SNO NUMBER(4),NAME VARCHAR2(10), COUNT NUMBER(7),
CONSTRAINT ORDERS_NO_PK PRIMARY KEY(NO));

INSERT INTO ORDERS VALUES(10,100,'AAA',10);
INSERT INTO ORDERS VALUES(20,200,'BBB',20);
INSERT INTO ORDERS VALUES(30,300,'CCC',30);
INSERT INTO ORDERS VALUES(40,400,'DDD',40);

DESC ORDERS;
SELECT * FROM ORDERS;

--FOREIGN KEY
ALTER TABLE CUSTOMER ADD CONSTRAINT CUSTOMER_NO_FK FOREIGN KEY(NO)
REFERENCES ORDERS(NO);

SELECT * FROM USER_CONSTRAINTS;

SELECT * FROM CUSTOMER;
INSERT INTO CUSTOMER VALUES(11,'AAA',10);--O
INSERT INTO CUSTOMER VALUES(22,'BBB',20);--O
INSERT INTO CUSTOMER VALUES(33,'CCC',50);--X, FK다름

--하나의 PK를 여러개의 FK가 참조 가능
CREATE TABLE CATALOGS (COTALOGNO NUMBER(4) CONSTRAINT CALTALOGS_CATALOGNO_PK PRIMARY KEY,
NAME VARCHAR2(10), NO NUMBER(4) CONSTRAINT CATALOGS_NO_FK REFERENCES ORDERS(NO));

DESC CATALOGS;

SELECT * FROM CATALOGS;
INSERT INTO CATALOGS VALUES(11,'AAA',10);--O
INSERT INTO CATALOGS VALUES(22,'BBB',40);--O
INSERT INTO CATALOGS VALUES(33,'CCC',50);--X


--UNIQUE
--NULL허용
SELECT * FROM ORDERS;
DESC ORDERS;

ALTER TABLE ORDERS ADD CONSTRAINT ORDERS_SNO_UK UNIQUE (SNO);

SELECT * FROM USER_CONSTRAINTS;

SELECT * FROM ORDERS;
INSERT INTO ORDERS VALUES(50,400,'DDD',40);--X
INSERT INTO ORDERS VALUES(50,NULL,'EEE',50);--O
INSERT INTO ORDERS VALUES(60,NULL,'FFF',60);--O

CREATE TABLE AAA(ID NUMBER, JUMIN VARCHAR2(14) CONSTRAINT AAA_JUMIN_UK UNIQUE);

--CHECK
ALTER TABLE ORDERS ADD CONSTRAINT ORDERS_SNO_CK CHECK(SNO BETWEEN 100 AND 500);

SELECT * FROM USER_CONSTRAINTS;

SELECT * FROM ORDERS;
INSERT INTO ORDERS VALUES(70,500,'GGG',70);--O
INSERT INTO ORDERS VALUES(80,501,'HHH',80);--X

COMMIT;

--NOT NULL
CREATE TABLE TEST1
(NO NUMBER(4) CONSTRAINT TEST1_NO_PK PRIMARY KEY,
NAME VARCHAR2(10) CONSTRAINT TEST1_NAME_NN NOT NULL,
CREATED DATE DEFAULT SYSDATE);

INSERT INTO TEST1 (NO,NAME) VALUES(10,'AAA');--O

INSERT INTO TEST1 (NO,NAME) VALUES(10,'');--X


-----------------------------------------------------------

--DICTIONARY : 필요한 데이터를 가지고 있는 테이블이나 뷰

--종류
--USER_ : USER 소유의 OBJECT 정보
--ALL_ : USER에게 ACCESS가 허용된 OBJECT의 정보
--DBA_ : DBA권한을 가진 USER가 ACCESS할수있는 정보
--V$ : 서버의 성능에 대한 정보

SELECT * FROM DICTIONARY;
SELECT COUNT(*) FROM DICTIONARY;

--USER가 ACCESS할 수있는 컬럼별 제약조건
SELECT * FROM ALL_CONS_COLUMNS;--O

SELECT * FROM USER_CONS_COLUMNS;--O

--모든 테이블의 제약조건
SELECT * FROM DBA_CONSTRAINTS;--X, DBA권한없음

SELECT * FROM V$VERSION;

SELECT * FROM USER_TABLES;
SELECT * FROM TABS;

SELECT * FROM USER_VIEWS;
--권한
SELECT * FROM USER_SYS_PRIVS;

--VIEW : 실제로 저장된 테이블이 아닌 가상의 테이블
--보안 땜에 만듬

SELECT * FROM USER_CONSTRAINTS;


CREATE VIEW DIV30
AS SELECT * FROM PERSONNEL WHERE DNO=30;

SELECT * FROM DIV30;


CREATE VIEW PER10_V
AS SELECT * FROM PERSONNEL WHERE DNO = 10;

SELECT * FROM PER10_V;

SELECT * FROM TABS;


CREATE VIEW PER20_V
AS SELECT PNO,PNAME,MANAGER,PAY,DNO FROM PERSONNEL;

SELECT * FROM PER20_V;

CREATE VIEW PER_AVG
AS SELECT DNO,AVG(PAY) 평균,SUM(PAY) 합계 FROM PERSONNEL GROUP BY DNO;

SELECT * FROM PER_AVG;

SELECT * FROM PER_AVG WHERE DNO = 10;

SELECT * FROM PER10_V WHERE PAY > 4000;

--VIEW 데이터를 바꾸면 원래 테이블도 바뀜
INSERT INTO PER20_V VALUES (1234,'AAAA',1001,2000,10);

SELECT * FROM PER20_V;
SELECT * FROM PERSONNEL;

UPDATE PER20_V SET PNAME = 'BBBB' WHERE PNO = 1234;
SELECT * FROM PER20_V;

DELETE PER20_V WHERE PNO=1234;
SELECT * FROM PER20_V;

--에러
--조인문으로 만든 VIEW는 INSERT,UPDATE,DELETE 불가
--PK가 없는 VIEW는 INSERT,UPDATE,DELETE 불가 
--그룹함수를 사용한 VIEW는 INSERT,UPDATE,DELETE 불가 

CREATE VIEW PER
AS SELECT PNAME,JOB,PAY FROM PERSONNEL;

SELECT * FROM PER;

SELECT * FROM PER_AVG;


--VIEW 수정
--ALTER VIEW --X
--CREATE OR REPLACE --O

SELECT * FROM USER_VIEWS;

SELECT * FROM PER20_V;

--없으면 만들고 있으면 수정함
CREATE OR REPLACE VIEW PER20_V
(번호,이름,직업,부서번호) AS SELECT PNO,PNAME,JOB,DNO FROM PERSONNEL 
WHERE DNO=20;

SELECT * FROM PER20_V;


CREATE OR REPLACE VIEW CCC
AS SELECT * FROM PERSONNEL WHERE DNO=10;

SELECT * FROM CCC;


--VIEW 삭제
DROP VIEW CCC;
DROP VIEW PER_AVG;

SELECT * FROM PER10_V;


UPDATE PER10_V SET DNO=20 WHERE PNO=1111;

SELECT * FROM PER10_V;
SELECT * FROM PERSONNEL;

--WITH CHECK OPTION CONSTRAINT, CHECK 제약조건 부여,제약조건에 위배되는 수정 불가
CREATE OR REPLACE VIEW PER10_V
AS SELECT * FROM PERSONNEL WHERE DNO = 10
WITH CHECK OPTION CONSTRAINT DNO10_V_CK;

UPDATE PER10_V SET DNO=20 WHERE PNO=1001;

SELECT * FROM PER10_V;

--삭제는 가능
DELETE PER10_V WHERE PNO=1001;
SELECT * FROM PER10_V;

--WITH READ ONLY, 읽기만 가능,수정 삭제 불가
CREATE OR REPLACE VIEW PER10_V
AS SELECT PNO,PNAME,JOB FROM PERSONNEL WHERE DNO = 10
WITH READ ONLY;

SELECT * FROM PER10_V;
DELETE PER10_V WHERE PNO = 1118;--X

-------------------------------------------------------------------------

-- TOP-N
--가장 최근에 입사한 5명의 사원의 이름과 입사일
--중요 게시판에서 많이씀

SELECT * FROM PERSONNEL;

--ROWNUM, 일련번호를 붙임
SELECT ROWNUM , PNAME FROM PERSONNEL;

SELECT ROWNUM,PNAME,STARTDATE FROM (SELECT PNAME,STARTDATE FROM PERSONNEL ORDER BY STARTDATE DESC)
WHERE ROWNUM <= 5;

--ROWNUM이 2~4까지,한번더 묶어줘야함
SELECT ROWNUM,PNAME,STARTDATE FROM (SELECT PNAME,STARTDATE FROM PERSONNEL ORDER BY STARTDATE DESC)
WHERE ROWNUM >=2 AND ROWNUM <= 4;--X

--ROWNUM 별칭 해줘야함
SELECT RNUM,PNAME,STARTDATE FROM
(SELECT ROWNUM RNUM,PNAME,STARTDATE FROM (SELECT PNAME,STARTDATE FROM PERSONNEL ORDER BY STARTDATE DESC))
WHERE RNUM >=2 AND RNUM <= 4; --O

--SELECT TOP 5 PNAME,STARTDATE FROM PERSONNEL ORDER BY STARTDATE DESC; MSSQL버전
--SELECT TOP 5 PERCENT PNAME,STARTDATE FROM PERSONNEL ORDER BY STARTDATE DESC; MSSQL버전


--SYNONYM(동의어)
--다른 유저 객체 사용할때 유저 이름(스키마)와 객체 이름 사용하는데 그거 감춰서 보안 강화
CREATE SYNONYM SALARY FOR PAYGRADE;

SELECT * FROM PAYGRADE;
SELECT * FROM SALARY;

CREATE SYNONYM INSA FOR KIM.PERSONNEL;

SELECT * FROM INSA;

SELECT * FROM USER_SYNONYMS;

DROP SYNONYM INSA;


--INDEX(색인)
--검색 빠름, 추가, 수정, 삭제 느림
--5~20% 별도 공간 필요

--BLOCK : 8KB
--EXTENT : 기본 64KB, 크기 설정 가능

--NON CLUSTERED TABLE :넣은 순서대로 들어감 ,정렬 X ,SELECT 속도 느림, INSERT,UPDATE,DELETE 속도 빠름
--CLUSTERED TABLE : 데이터 넣는 순간 정렬, SELECT 속도 빠름, INSERT,UPDATE,DELETE 속도 느림

SELECT * FROM PERSONNEL;
--PK는 기본적으로 INDEX존재
SELECT * FROM PERSONNEL WHERE PNO =1111;
--TABLE SCAN
SELECT * FROM PERSONNEL WHERE JOB ='SALESMAN';

--JOB에 인덱스 생성
CREATE INDEX PER_IDX
ON PERSONNEL(JOB);

--ROWID, 데이터 블록 번호
SELECT ROWID,PNAME FROM PERSONNEL;

SELECT * FROM USER_INDEXES;


CREATE TABLE ABC
(ID NUMBER(4) CONSTRAINT ABC_ID_PK PRIMARY KEY, NAME CHAR(10));

SELECT * FROM USER_CONSTRAINTS;
SELECT * FROM USER_INDEXES;


--c:\zipcode\post.csv불러오기
CREATE TABLE post (
	seq  NUMBER  NOT NULL
	,zipcode  VARCHAR2(10)
	,sido  VARCHAR2(50)
	,gugun  VARCHAR2(100)
	,dong  VARCHAR2(100)
	,bunji  VARCHAR2(50)
        ,PRIMARY KEY (seq)
);

SELECT * FROM POST WHERE DONG = '행복동';
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME ='POST';

--DONG에 인덱스 생성
CREATE INDEX POST_IDX ON POST(DONG);

SELECT * FROM USER_INDEXES WHERE TABLE_NAME='POST';

------------------------------------------------------------------

--SEQUENCE
--중복되지 않은 숫자 부여
SELECT ROWNUM,PNAME FROM PERSONNEL;

--1부터 100까지 1씩증가 20씩 메모리에 올림, 반복X
CREATE SEQUENCE DIV_NO 
START WITH 1 INCREMENT BY 1 MAXVALUE 100 --NOMAXVALUE
NOCYCLE --CYCLE(반복)
CACHE 20; --NOCACHE : 메모리에 1씩 올림


--CURRVAL : DIV_NO.CURRVAL, 현재 시퀀스
--NEXTVAL : DIV_NO.NEXTVAL, 다음 시퀀스

SELECT DIV_NO.NEXTVAL FROM DUAL;

SELECT DIV_NO.CURRVAL FROM DUAL;

INSERT INTO DIVISION(DNO,DNAME,POSITION) VALUES (DIV_NO.NEXTVAL,'DEVELOP','KOREA');

SELECT * FROM DIVISION;

SELECT * FROM USER_SEQUENCES;

ALTER SEQUENCE DIV_NO 
INCREMENT BY 10 
MAXVALUE 99
NOCACHE
NOCYCLE;

SELECT * FROM USER_SEQUENCES;

DROP SEQUENCE DIV_NO;

/*
--MSSQL SEQUENCE
CREATE TABLE AAA
(ID INT IDENTIFY(1,1),
NAME CHAR(10));

--MYSQL SEQUECE
CREATE TABLE AAA
(ID NUMBER AUTOINCREMENT,
NAME CHAR(10));
*/


----------------------------------------------------------

--PLSQL













































